warning[backslash]: File name contains \, use / instead (\ fails on most of the supported platforms): C:\SpecNext\Projects\NextLibrary\Source\NextLibrary.asm
# file opened: NextLibrary.asm
  1   0000                              OPT     --zxnext
  2   0000                              DEVICE  ZXSPECTRUMNEXT
  3   0000                              ORG     0x8000
  4   8000
  5   8000              StartAddress:   ; Main program entry point
  6   8000 ED 73 17 81                  LD      (OriginalStack), SP                ; Save original stack pointer first
  7   8004 31 15 81                     LD      SP, StackTop                       ; Set up our stack pointer
  8   8007
  9   8007                              ; Initialize display system
 10   8007 CD 4D 81                     CALL    InitDisplay
 11   800A CD 28 81                     CALL    ClearScreen
 12   800D
 13   800D                              ; Run the test pack
 14   800D CD 33 8C                     CALL    RunTests
 15   8010
 16   8010 ED 7B 17 81                  LD      SP, (OriginalStack)                ; Restore original stack pointer
 17   8014 C9                           RET
 18   8015
 19   8015              VariablesEtc:   INCLUDE "Constants.asm"                    ; Include the Constants definitions
# file opened: Constants.asm
  1+  8015              ; Screen dimensions and memory layout
  2+  8015              SCREEN_WIDTH                    EQU     32      ; Characters per row
  3+  8015              SCREEN_HEIGHT                   EQU     24      ; Rows
  4+  8015              SCREEN_PIXEL_BASE               EQU     0x4000  ; Start of pixel memory
  5+  8015              SCREEN_ATTR_BASE                EQU     0x5800  ; Start of attribute memory
  6+  8015
  7+  8015              ; Performance levels for multiply and divide routines.
  8+  8015              PERFORMANCE_COMPACT             EQU     0       ; Smallest code base required
  9+  8015              PERFORMANCE_BALANCED            EQU     1       ; Balance between speed and memory usage
 10+  8015              PERFORMANCE_MAXIMUM             EQU     2       ; Maximum speed but larger memory usage
 11+  8015
 12+  8015              ; Random number generator options
 13+  8015              PERFORMANCE_RANDOM_LCG          EQU     0       ; Fast, good distribution, full period
 14+  8015              PERFORMANCE_RANDOM_LFSR         EQU     1       ; Best quality, maximum period, moderate speed
 15+  8015              PERFORMANCE_RANDOM_XORSHIFT     EQU     2       ; Fastest execution, very good quality, likley best for games.
 16+  8015              PERFORMANCE_RANDOM_MIDDLESQUARE EQU     3       ; Educational software use only.
# file closed: Constants.asm
 20   8015                              INCLUDE "Variables.asm"                    ; Include the Variables definitions
# file opened: Variables.asm
  1+  8015              ; Simple stack setup
  2+  8015 00 00 00...  StackSpace:                 DS      256             ; 256 bytes for stack, add more space if a bigger stack area is needed
  3+  8115 00 00        StackTop:                   DS      2               ; Storage for stack top pointer
  4+  8117 00 00        OriginalStack:              DS      2               ; Storage for original stack pointer
  5+  8119
  6+  8119
  7+  8119              ; Current cursor position (global text variables)
  8+  8119 00           CursorRow:                  DB      0               ; Current row (0-23)
  9+  811A 00           CursorCol:                  DB      0               ; Current column (0-31)
 10+  811B 07           CurrentAttr:                DB      0x07            ; Current attribute (white on black)
 11+  811C
 12+  811C              ; Random Generator Store - default values set in case you forget to seed at least once.
 13+  811C 01           RandomSeed8_CurrentSeed:    DB      1               ; Current seed value (initialized to 1)
 14+  811D 01           LfsrSeed8_State:            DB      1               ; LFSR state (never 0)
 15+  811E 01           MiddleSquareSeed8_State:    DB      1               ; Middle Square state
 16+  811F 01           XorShiftSeed8_State:        DB      1               ; XORShift state (never 0)
 17+  8120
 18+  8120 D2 04        RandomSeed16_CurrentSeed:   DW      1234            ; Current seed value (initialized to 1234)
 19+  8122 D2 04        LfsrSeed16_State:           DW      1234            ; LFSR state (never 0)
 20+  8124 D2 04        MiddleSquareSeed16_State:   DW      1234            ; Middle Square state
 21+  8126 D2 04        XorShiftSeed16_State:       DW      1234            ; XORShift state (never 0)
 22+  8128
# file closed: Variables.asm
 21   8128
 22   8128              DisplayUtils:   INCLUDE "Display/ScreenUtils.asm"          ; Include the Screen Utils routines
# file opened: ScreenUtils.asm
  1+  8128              ; Clear the entire screen using direct memory access
  2+  8128              ClearScreen:        ; Clear pixel memory (0x4000-0x57FF)
  3+  8128 21 00 40                         LD      HL, SCREEN_PIXEL_BASE
  4+  812B 11 01 40                         LD      DE, SCREEN_PIXEL_BASE + 1
  5+  812E 01 00 18                         LD      BC, 0x1800      ; 6144 bytes
  6+  8131 36 00                            LD      (HL), 0         ; Clear first byte
  7+  8133 ED B0                            LDIR                    ; Clear rest
  8+  8135
  9+  8135                                  ; Clear attribute memory (0x5800-0x5AFF)
 10+  8135 21 00 58                         LD      HL, SCREEN_ATTR_BASE
 11+  8138 11 01 58                         LD      DE, SCREEN_ATTR_BASE + 1
 12+  813B 01 FF 02                         LD      BC, 0x02FF      ; 767 bytes
 13+  813E 3A 1B 81                         LD      A, (CurrentAttr)
 14+  8141 77                               LD      (HL), A         ; Set first attribute
 15+  8142 ED B0                            LDIR                    ; Set rest
 16+  8144
 17+  8144                                  ; Reset cursor position
 18+  8144 3E 00                            LD      A, 0
 19+  8146 32 19 81                         LD      (CursorRow), A
 20+  8149 32 1A 81                         LD      (CursorCol), A
 21+  814C C9                               RET
 22+  814D
# file closed: ScreenUtils.asm
 23   814D                              INCLUDE "Display/TextUtils.asm"            ; Include the Text Utils routines
# file opened: TextUtils.asm
  1+  814D
  2+  814D              ; Initialize system
  3+  814D 3E 00        InitDisplay:        LD      A, 0
  4+  814F 32 19 81                         LD      (CursorRow), A
  5+  8152 32 1A 81                         LD      (CursorCol), A
  6+  8155 3E 07                            LD      A, 0x07         ; White on black
  7+  8157 32 1B 81                         LD      (CurrentAttr), A
  8+  815A C9                               RET
  9+  815B
 10+  815B              ; Set cursor position
 11+  815B              ; Input: B = row (0-23), C = column (0-31)
 12+  815B 78           SetCursor:          LD      A, B
 13+  815C FE 18                            CP      SCREEN_HEIGHT
 14+  815E 30 0D                            JR      NC, SetCursor_End ; Row out of bounds
 15+  8160 79                               LD      A, C
 16+  8161 FE 20                            CP      SCREEN_WIDTH
 17+  8163 30 08                            JR      NC, SetCursor_End ; Column out of bounds
 18+  8165
 19+  8165 78                               LD      A, B
 20+  8166 32 19 81                         LD      (CursorRow), A
 21+  8169 79                               LD      A, C
 22+  816A 32 1A 81                         LD      (CursorCol), A
 23+  816D C9           SetCursor_End:      RET
 24+  816E
 25+  816E              ; Print a character using direct screen memory access
 26+  816E              ; Input: A = character to print
 27+  816E F5           PrintChar:          PUSH    AF
 28+  816F C5                               PUSH    BC
 29+  8170 D5                               PUSH    DE
 30+  8171 E5                               PUSH    HL
 31+  8172
 32+  8172                                  ; Handle special characters
 33+  8172 FE 0D                            CP      13              ; Carriage return
 34+  8174 28 10                            JR      Z, PrintChar_CR
 35+  8176 FE 0A                            CP      10              ; Line feed
 36+  8178 28 13                            JR      Z, PrintChar_LF
 37+  817A FE 20                            CP      32              ; Space or higher
 38+  817C 38 1C                            JR      C, PrintChar_End ; Skip control chars (except CR/LF)
 39+  817E
 40+  817E                                  ; Print normal character
 41+  817E CD 9F 81                         CALL    PrintChar_Normal
 42+  8181 CD F8 81                         CALL    AdvanceCursor
 43+  8184 18 14                            JR      PrintChar_End
 44+  8186
 45+  8186              PrintChar_CR:       ; Carriage return - move to start of current line
 46+  8186 3E 00                            LD      A, 0
 47+  8188 32 1A 81                         LD      (CursorCol), A
 48+  818B 18 0D                            JR      PrintChar_End
 49+  818D
 50+  818D              PrintChar_LF:       ; Line feed - move to next line
 51+  818D 3A 19 81                         LD      A, (CursorRow)
 52+  8190 3C                               INC     A
 53+  8191 FE 18                            CP      SCREEN_HEIGHT
 54+  8193 38 02                            JR      C, PrintChar_LF_OK
 55+  8195                                  ; Scroll screen up (simplified - just go to top for now)
 56+  8195 3E 00                            LD      A, 0
 57+  8197 32 19 81     PrintChar_LF_OK:    LD      (CursorRow), A
 58+  819A
 59+  819A E1           PrintChar_End:      POP     HL
 60+  819B D1                               POP     DE
 61+  819C C1                               POP     BC
 62+  819D F1                               POP     AF
 63+  819E C9                               RET
 64+  819F
 65+  819F              ; Print normal character (internal routine)
 66+  819F              ; Input: A = character, uses cursor position
 67+  819F              PrintChar_Normal:   ; Get character font data (use embedded font)
 68+  819F F5                               PUSH    AF
 69+  81A0 21 67 82                         LD      HL, EmbeddedFont ; Use our embedded font
 70+  81A3 D6 20                            SUB     32              ; ASCII 32 is first printable
 71+  81A5 16 00                            LD      D, 0
 72+  81A7 5F                               LD      E, A
 73+  81A8 19                               ADD     HL, DE
 74+  81A9 19                               ADD     HL, DE
 75+  81AA 19                               ADD     HL, DE
 76+  81AB 19                               ADD     HL, DE
 77+  81AC 19                               ADD     HL, DE
 78+  81AD 19                               ADD     HL, DE
 79+  81AE 19                               ADD     HL, DE
 80+  81AF 19                               ADD     HL, DE          ; Each char is 8 bytes
 81+  81B0
 82+  81B0                                  ; Get screen position for current cursor
 83+  81B0 CD C7 81                         CALL    GetScreenAddress
 84+  81B3                                  ; DE now points to screen memory
 85+  81B3
 86+  81B3                                  ; Copy 8 bytes of character data
 87+  81B3 06 08                            LD      B, 8
 88+  81B5 7E           PrintChar_Loop:     LD      A, (HL)
 89+  81B6 12                               LD      (DE), A
 90+  81B7 23                               INC     HL
 91+  81B8 7A                               LD      A, D
 92+  81B9 C6 01                            ADD     A, 1            ; Move to next pixel row
 93+  81BB 57                               LD      D, A
 94+  81BC 10 F7                            DJNZ    PrintChar_Loop
 95+  81BE
 96+  81BE                                  ; Set attribute
 97+  81BE CD E0 81                         CALL    GetAttrAddress
 98+  81C1 3A 1B 81                         LD      A, (CurrentAttr)
 99+  81C4 12                               LD      (DE), A
100+  81C5
101+  81C5 F1                               POP     AF
102+  81C6 C9                               RET
103+  81C7
104+  81C7              ; Get screen memory address for current cursor position
105+  81C7              ; Output: DE = screen memory address
106+  81C7 3A 19 81     GetScreenAddress:   LD      A, (CursorRow)
107+  81CA 57                               LD      D, A
108+  81CB 3A 1A 81                         LD      A, (CursorCol)
109+  81CE 5F                               LD      E, A
110+  81CF
111+  81CF                                  ; Calculate screen address: Base + (row * 256) + (row & 7) * 32 + col
112+  81CF                                  ; Simplified for now - just do basic calculation
113+  81CF 7A                               LD      A, D            ; Row
114+  81D0 E6 18                            AND     0x18            ; Get high bits of row
115+  81D2 C6 40                            ADD     A, 0x40         ; Add screen base high byte
116+  81D4 57                               LD      D, A
117+  81D5
118+  81D5 3A 19 81                         LD      A, (CursorRow)  ; Row again
119+  81D8 E6 07                            AND     0x07            ; Get low bits
120+  81DA 0F                               RRCA
121+  81DB 0F                               RRCA
122+  81DC 0F                               RRCA                    ; Multiply by 32
123+  81DD 83                               ADD     A, E            ; Add column
124+  81DE 5F                               LD      E, A
125+  81DF C9                               RET
126+  81E0
127+  81E0              ; Get attribute memory address for current cursor position
128+  81E0              ; Output: DE = attribute memory address
129+  81E0 3A 19 81     GetAttrAddress:     LD      A, (CursorRow)
130+  81E3 16 00                            LD      D, 0
131+  81E5 5F                               LD      E, A
132+  81E6 19                               ADD     HL, DE
133+  81E7 19                               ADD     HL, DE
134+  81E8 19                               ADD     HL, DE
135+  81E9 19                               ADD     HL, DE
136+  81EA 19                               ADD     HL, DE          ; Row * 32
137+  81EB 11 00 58                         LD      DE, SCREEN_ATTR_BASE
138+  81EE 19                               ADD     HL, DE
139+  81EF 3A 1A 81                         LD      A, (CursorCol)
140+  81F2 5F                               LD      E, A
141+  81F3 16 00                            LD      D, 0
142+  81F5 19                               ADD     HL, DE          ; Add column
143+  81F6 EB                               EX      DE, HL          ; Result in DE
144+  81F7 C9                               RET
145+  81F8
146+  81F8              ; Advance cursor to next position
147+  81F8 3A 1A 81     AdvanceCursor:      LD      A, (CursorCol)
148+  81FB 3C                               INC     A
149+  81FC FE 20                            CP      SCREEN_WIDTH
150+  81FE 38 13                            JR      C, AdvanceCursor_OK
151+  8200
152+  8200                                  ; Wrap to next line
153+  8200 3E 00                            LD      A, 0
154+  8202 32 1A 81                         LD      (CursorCol), A
155+  8205 3A 19 81                         LD      A, (CursorRow)
156+  8208 3C                               INC     A
157+  8209 FE 18                            CP      SCREEN_HEIGHT
158+  820B 38 02                            JR      C, AdvanceCursor_Row_OK
159+  820D 3E 00                            LD      A, 0            ; Wrap to top (simplified scrolling)
160+  820F 32 19 81     AdvanceCursor_Row_OK: LD    (CursorRow), A
161+  8212 C9                               RET
162+  8213
163+  8213 32 1A 81     AdvanceCursor_OK:   LD      (CursorCol), A
164+  8216 C9                               RET
165+  8217
166+  8217              ; Print a null-terminated string using direct screen memory
167+  8217              ; Input: HL = pointer to string
168+  8217 7E           PrintString:        LD      A, (HL)         ; Get character
169+  8218 B7                               OR      A               ; Check if zero
170+  8219 C8                               RET     Z               ; Return if end of string
171+  821A CD 6E 81                         CALL    PrintChar       ; Print using our direct routine
172+  821D 23                               INC     HL              ; Next character
173+  821E 18 F7                            JR      PrintString     ; Continue
174+  8220
175+  8220              ; Print a decimal number (0-255) using direct screen memory
176+  8220              ; Input: A = number to print
177+  8220 57           PrintDecimal:       LD      D, A            ; Save number
178+  8221 1E 00                            LD      E, 0            ; Hundreds counter
179+  8223
180+  8223                                  ; Extract hundreds
181+  8223 7A           PrintDec_Hundreds:  LD      A, D
182+  8224 FE 64                            CP      100
183+  8226 38 06                            JR      C, PrintDec_Tens
184+  8228 D6 64                            SUB     100
185+  822A 57                               LD      D, A
186+  822B 1C                               INC     E
187+  822C 18 F5                            JR      PrintDec_Hundreds
188+  822E
189+  822E 7B           PrintDec_Tens:      LD      A, E            ; Hundreds
190+  822F B7                               OR      A
191+  8230 28 05                            JR      Z, PrintDec_SkipH
192+  8232 C6 30                            ADD     A, '0'
193+  8234 CD 6E 81                         CALL    PrintChar
194+  8237
195+  8237 06 00        PrintDec_SkipH:     LD      B, 0            ; Tens counter
196+  8239 7A           PrintDec_TensLoop:  LD      A, D
197+  823A FE 0A                            CP      10
198+  823C 38 06                            JR      C, PrintDec_Units
199+  823E D6 0A                            SUB     10
200+  8240 57                               LD      D, A
201+  8241 04                               INC     B
202+  8242 18 F5                            JR      PrintDec_TensLoop
203+  8244
204+  8244 78           PrintDec_Units:     LD      A, B            ; Tens
205+  8245 B3                               OR      E               ; Check if we printed hundreds
206+  8246 28 06                            JR      Z, PrintDec_SkipT
207+  8248 78                               LD      A, B
208+  8249 C6 30                            ADD     A, '0'
209+  824B CD 6E 81                         CALL    PrintChar
210+  824E
211+  824E 7A           PrintDec_SkipT:     LD      A, D            ; Units
212+  824F C6 30                            ADD     A, '0'
213+  8251 CD 6E 81                         CALL    PrintChar
214+  8254 C9                               RET
215+  8255
216+  8255              ; Set text color attribute
217+  8255              ; Input: A = attribute byte
218+  8255 32 1B 81     SetTextColor:       LD      (CurrentAttr), A
219+  8258 C9                               RET
220+  8259
221+  8259              ; Print at specific position
222+  8259              ; Input: B = row, C = column, HL = string
223+  8259 CD 5B 81     PrintAt:            CALL    SetCursor
224+  825C CD 17 82                         CALL    PrintString
225+  825F C9                               RET
226+  8260
227+  8260              ; Alias for PrintAt with more descriptive name
228+  8260              ; Input: B = row, C = column, HL = string
229+  8260 CD 5B 81     PrintStringAt:      CALL    SetCursor
230+  8263 CD 17 82                         CALL    PrintString
231+  8266 C9                               RET
232+  8267
# file closed: TextUtils.asm
 24   8267                              INCLUDE "Display/EmbeddedFont.asm"         ; Include the Embedded Font
# file opened: EmbeddedFont.asm
  1+  8267              ; Embedded font data - complete 8x8 font for all printable ASCII characters (32-126)
  2+  8267              ; Each character is 8 bytes representing 8 rows of 8 pixels
  3+  8267              EmbeddedFont:
  4+  8267                                  ; ASCII 32 (Space)
  5+  8267 00 00 00 00                      DB      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  5+  826B 00 00 00 00
  6+  826F                                  ; ASCII 33 (!)
  7+  826F 18 18 18 18                      DB      0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00
  7+  8273 18 00 18 00
  8+  8277                                  ; ASCII 34 (")
  9+  8277 6C 6C 6C 00                      DB      0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00
  9+  827B 00 00 00 00
 10+  827F                                  ; ASCII 35 (#)
 11+  827F 6C 6C FE 6C                      DB      0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00
 11+  8283 FE 6C 6C 00
 12+  8287                                  ; ASCII 36 ($)
 13+  8287 18 3E 60 3C                      DB      0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00
 13+  828B 06 7C 18 00
 14+  828F                                  ; ASCII 37 (%)
 15+  828F 00 C6 CC 18                      DB      0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00
 15+  8293 30 66 C6 00
 16+  8297                                  ; ASCII 38 (&)
 17+  8297 38 6C 38 76                      DB      0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00
 17+  829B DC CC 76 00
 18+  829F                                  ; ASCII 39 (')
 19+  829F 18 18 30 00                      DB      0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00
 19+  82A3 00 00 00 00
 20+  82A7                                  ; ASCII 40 (()
 21+  82A7 0C 18 30 30                      DB      0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00
 21+  82AB 30 18 0C 00
 22+  82AF                                  ; ASCII 41 ())
 23+  82AF 30 18 0C 0C                      DB      0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00
 23+  82B3 0C 18 30 00
 24+  82B7                                  ; ASCII 42 (*)
 25+  82B7 00 66 3C FF                      DB      0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00
 25+  82BB 3C 66 00 00
 26+  82BF                                  ; ASCII 43 (+)
 27+  82BF 00 18 18 7E                      DB      0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00
 27+  82C3 18 18 00 00
 28+  82C7                                  ; ASCII 44 (,)
 29+  82C7 00 00 00 00                      DB      0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30
 29+  82CB 00 18 18 30
 30+  82CF                                  ; ASCII 45 (-)
 31+  82CF 00 00 00 7E                      DB      0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00
 31+  82D3 00 00 00 00
 32+  82D7                                  ; ASCII 46 (.)
 33+  82D7 00 00 00 00                      DB      0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00
 33+  82DB 00 18 18 00
 34+  82DF                                  ; ASCII 47 (/)
 35+  82DF 06 0C 18 30                      DB      0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00
 35+  82E3 60 C0 80 00
 36+  82E7                                  ; ASCII 48 (0)
 37+  82E7 3C 66 6E 7E                      DB      0x3C, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x3C, 0x00
 37+  82EB 76 66 3C 00
 38+  82EF                                  ; ASCII 49 (1)
 39+  82EF 18 38 18 18                      DB      0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00
 39+  82F3 18 18 7E 00
 40+  82F7                                  ; ASCII 50 (2)
 41+  82F7 3C 66 06 1C                      DB      0x3C, 0x66, 0x06, 0x1C, 0x30, 0x60, 0x7E, 0x00
 41+  82FB 30 60 7E 00
 42+  82FF                                  ; ASCII 51 (3)
 43+  82FF 3C 66 06 1C                      DB      0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00
 43+  8303 06 66 3C 00
 44+  8307                                  ; ASCII 52 (4)
 45+  8307 1C 3C 6C CC                      DB      0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00
 45+  830B FE 0C 1E 00
 46+  830F                                  ; ASCII 53 (5)
 47+  830F 7E 60 7C 06                      DB      0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00
 47+  8313 06 66 3C 00
 48+  8317                                  ; ASCII 54 (6)
 49+  8317 3C 66 60 7C                      DB      0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00
 49+  831B 66 66 3C 00
 50+  831F                                  ; ASCII 55 (7)
 51+  831F 7E 66 0C 18                      DB      0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00
 51+  8323 18 18 18 00
 52+  8327                                  ; ASCII 56 (8)
 53+  8327 3C 66 66 3C                      DB      0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00
 53+  832B 66 66 3C 00
 54+  832F                                  ; ASCII 57 (9)
 55+  832F 3C 66 66 3E                      DB      0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00
 55+  8333 06 66 3C 00
 56+  8337                                  ; ASCII 58 (:)
 57+  8337 00 18 18 00                      DB      0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00
 57+  833B 00 18 18 00
 58+  833F                                  ; ASCII 59 (;)
 59+  833F 00 18 18 00                      DB      0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30
 59+  8343 00 18 18 30
 60+  8347                                  ; ASCII 60 (<)
 61+  8347 0E 1C 38 70                      DB      0x0E, 0x1C, 0x38, 0x70, 0x38, 0x1C, 0x0E, 0x00
 61+  834B 38 1C 0E 00
 62+  834F                                  ; ASCII 61 (=)
 63+  834F 00 00 7E 00                      DB      0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00
 63+  8353 7E 00 00 00
 64+  8357                                  ; ASCII 62 (>)
 65+  8357 70 38 1C 0E                      DB      0x70, 0x38, 0x1C, 0x0E, 0x1C, 0x38, 0x70, 0x00
 65+  835B 1C 38 70 00
 66+  835F                                  ; ASCII 63 (?)
 67+  835F 3C 66 06 0C                      DB      0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00
 67+  8363 18 00 18 00
 68+  8367                                  ; ASCII 64 (@)
 69+  8367 3C 66 6E 6E                      DB      0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00
 69+  836B 60 62 3C 00
 70+  836F                                  ; ASCII 65 (A)
 71+  836F 18 3C 66 7E                      DB      0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00
 71+  8373 66 66 66 00
 72+  8377                                  ; ASCII 66 (B)
 73+  8377 7C 66 66 7C                      DB      0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00
 73+  837B 66 66 7C 00
 74+  837F                                  ; ASCII 67 (C)
 75+  837F 3C 66 60 60                      DB      0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00
 75+  8383 60 66 3C 00
 76+  8387                                  ; ASCII 68 (D)
 77+  8387 78 6C 66 66                      DB      0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00
 77+  838B 66 6C 78 00
 78+  838F                                  ; ASCII 69 (E)
 79+  838F 7E 60 60 78                      DB      0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00
 79+  8393 60 60 7E 00
 80+  8397                                  ; ASCII 70 (F)
 81+  8397 7E 60 60 78                      DB      0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00
 81+  839B 60 60 60 00
 82+  839F                                  ; ASCII 71 (G)
 83+  839F 3C 66 60 6E                      DB      0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00
 83+  83A3 66 66 3C 00
 84+  83A7                                  ; ASCII 72 (H)
 85+  83A7 66 66 66 7E                      DB      0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00
 85+  83AB 66 66 66 00
 86+  83AF                                  ; ASCII 73 (I)
 87+  83AF 3C 18 18 18                      DB      0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00
 87+  83B3 18 18 3C 00
 88+  83B7                                  ; ASCII 74 (J)
 89+  83B7 1E 0C 0C 0C                      DB      0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00
 89+  83BB 0C 6C 38 00
 90+  83BF                                  ; ASCII 75 (K)
 91+  83BF 66 6C 78 70                      DB      0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00
 91+  83C3 78 6C 66 00
 92+  83C7                                  ; ASCII 76 (L)
 93+  83C7 60 60 60 60                      DB      0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00
 93+  83CB 60 60 7E 00
 94+  83CF                                  ; ASCII 77 (M)
 95+  83CF 63 77 7F 6B                      DB      0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00
 95+  83D3 63 63 63 00
 96+  83D7                                  ; ASCII 78 (N)
 97+  83D7 66 76 7E 7E                      DB      0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00
 97+  83DB 6E 66 66 00
 98+  83DF                                  ; ASCII 79 (O)
 99+  83DF 3C 66 66 66                      DB      0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00
 99+  83E3 66 66 3C 00
100+  83E7                                  ; ASCII 80 (P)
101+  83E7 7C 66 66 7C                      DB      0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00
101+  83EB 60 60 60 00
102+  83EF                                  ; ASCII 81 (Q)
103+  83EF 3C 66 66 66                      DB      0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00
103+  83F3 66 3C 0E 00
104+  83F7                                  ; ASCII 82 (R)
105+  83F7 7C 66 66 7C                      DB      0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00
105+  83FB 78 6C 66 00
106+  83FF                                  ; ASCII 83 (S)
107+  83FF 3C 66 60 3C                      DB      0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00
107+  8403 06 66 3C 00
108+  8407                                  ; ASCII 84 (T)
109+  8407 7E 18 18 18                      DB      0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00
109+  840B 18 18 18 00
110+  840F                                  ; ASCII 85 (U)
111+  840F 66 66 66 66                      DB      0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00
111+  8413 66 66 3C 00
112+  8417                                  ; ASCII 86 (V)
113+  8417 66 66 66 66                      DB      0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00
113+  841B 66 3C 18 00
114+  841F                                  ; ASCII 87 (W)
115+  841F 63 63 63 6B                      DB      0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00
115+  8423 7F 77 63 00
116+  8427                                  ; ASCII 88 (X)
117+  8427 66 66 3C 18                      DB      0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00
117+  842B 3C 66 66 00
118+  842F                                  ; ASCII 89 (Y)
119+  842F 66 66 66 3C                      DB      0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00
119+  8433 18 18 18 00
120+  8437                                  ; ASCII 90 (Z)
121+  8437 7E 06 0C 18                      DB      0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00
121+  843B 30 60 7E 00
122+  843F                                  ; ASCII 91 ([)
123+  843F 3C 30 30 30                      DB      0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00
123+  8443 30 30 3C 00
124+  8447                                  ; ASCII 92 (\)
125+  8447 C0 60 30 18                      DB      0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00
125+  844B 0C 06 02 00
126+  844F                                  ; ASCII 93 (])
127+  844F 3C 0C 0C 0C                      DB      0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00
127+  8453 0C 0C 3C 00
128+  8457                                  ; ASCII 94 (^)
129+  8457 10 38 6C C6                      DB      0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00
129+  845B 00 00 00 00
130+  845F                                  ; ASCII 95 (_)
131+  845F 00 00 00 00                      DB      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF
131+  8463 00 00 00 FF
132+  8467                                  ; ASCII 96 (`)
133+  8467 30 18 0C 00                      DB      0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00
133+  846B 00 00 00 00
134+  846F                                  ; ASCII 97 (a)
135+  846F 00 00 3C 06                      DB      0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00
135+  8473 3E 66 3E 00
136+  8477                                  ; ASCII 98 (b)
137+  8477 60 60 7C 66                      DB      0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00
137+  847B 66 66 7C 00
138+  847F                                  ; ASCII 99 (c)
139+  847F 00 00 3C 60                      DB      0x00, 0x00, 0x3C, 0x60, 0x60, 0x60, 0x3C, 0x00
139+  8483 60 60 3C 00
140+  8487                                  ; ASCII 100 (d)
141+  8487 06 06 3E 66                      DB      0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00
141+  848B 66 66 3E 00
142+  848F                                  ; ASCII 101 (e)
143+  848F 00 00 3C 66                      DB      0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00
143+  8493 7E 60 3C 00
144+  8497                                  ; ASCII 102 (f)
145+  8497 1C 36 30 78                      DB      0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x78, 0x00
145+  849B 30 30 78 00
146+  849F                                  ; ASCII 103 (g)
147+  849F 00 00 3E 66                      DB      0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x7C
147+  84A3 66 3E 06 7C
148+  84A7                                  ; ASCII 104 (h)
149+  84A7 60 60 6C 76                      DB      0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x00
149+  84AB 66 66 66 00
150+  84AF                                  ; ASCII 105 (i)
151+  84AF 18 00 38 18                      DB      0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00
151+  84B3 18 18 3C 00
152+  84B7                                  ; ASCII 106 (j)
153+  84B7 06 00 0E 06                      DB      0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x66, 0x3C
153+  84BB 06 06 66 3C
154+  84BF                                  ; ASCII 107 (k)
155+  84BF 60 60 66 6C                      DB      0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00
155+  84C3 78 6C 66 00
156+  84C7                                  ; ASCII 108 (l)
157+  84C7 38 18 18 18                      DB      0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00
157+  84CB 18 18 3C 00
158+  84CF                                  ; ASCII 109 (m)
159+  84CF 00 00 66 FE                      DB      0x00, 0x00, 0x66, 0xFE, 0xFE, 0xD6, 0xC6, 0x00
159+  84D3 FE D6 C6 00
160+  84D7                                  ; ASCII 110 (n)
161+  84D7 00 00 6C 76                      DB      0x00, 0x00, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x00
161+  84DB 66 66 66 00
162+  84DF                                  ; ASCII 111 (o)
163+  84DF 00 00 3C 66                      DB      0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00
163+  84E3 66 66 3C 00
164+  84E7                                  ; ASCII 112 (p)
165+  84E7 00 00 7C 66                      DB      0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60
165+  84EB 66 7C 60 60
166+  84EF                                  ; ASCII 113 (q)
167+  84EF 00 00 3E 66                      DB      0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06
167+  84F3 66 3E 06 06
168+  84F7                                  ; ASCII 114 (r)
169+  84F7 00 00 6C 76                      DB      0x00, 0x00, 0x6C, 0x76, 0x60, 0x60, 0x60, 0x00
169+  84FB 60 60 60 00
170+  84FF                                  ; ASCII 115 (s)
171+  84FF 00 00 3E 60                      DB      0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00
171+  8503 3C 06 7C 00
172+  8507                                  ; ASCII 116 (t)
173+  8507 30 30 7C 30                      DB      0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00
173+  850B 30 36 1C 00
174+  850F                                  ; ASCII 117 (u)
175+  850F 00 00 66 66                      DB      0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00
175+  8513 66 66 3E 00
176+  8517                                  ; ASCII 118 (v)
177+  8517 00 00 66 66                      DB      0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00
177+  851B 66 3C 18 00
178+  851F                                  ; ASCII 119 (w)
179+  851F 00 00 C6 D6                      DB      0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00
179+  8523 FE FE 6C 00
180+  8527                                  ; ASCII 120 (x)
181+  8527 00 00 66 3C                      DB      0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00
181+  852B 18 3C 66 00
182+  852F                                  ; ASCII 121 (y)
183+  852F 00 00 66 66                      DB      0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x0C, 0x78
183+  8533 66 3E 0C 78
184+  8537                                  ; ASCII 122 (z)
185+  8537 00 00 7E 0C                      DB      0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00
185+  853B 18 30 7E 00
186+  853F                                  ; ASCII 123 ({)
187+  853F 0E 18 18 70                      DB      0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00
187+  8543 18 18 0E 00
188+  8547                                  ; ASCII 124 (|)
189+  8547 18 18 18 00                      DB      0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00
189+  854B 18 18 18 00
190+  854F                                  ; ASCII 125 (})
191+  854F 70 18 18 0E                      DB      0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00
191+  8553 18 18 70 00
192+  8557                                  ; ASCII 126 (~)
193+  8557 76 DC 00 00                      DB      0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
193+  855B 00 00 00 00
194+  855F
# file closed: EmbeddedFont.asm
 25   855F
 26   855F              KeysHelpers:    INCLUDE "Input/InputScanUtils.asm"         ; Include the Input scanning routines
# file opened: InputScanUtils.asm
  1+  855F              ScanAllKeys:        ; scans all keys returning NZ set if a key is pressed, else returns Z set
  2+  855F 06 FE                            LD      B, 0xFE         ; First keyboard row
  3+  8561 CD 8F 85                         CALL    ScanKeyPort
  4+  8564 C0                               RET     NZ
  5+  8565                                  ; Check row 0xFD (A, S, D, F, G)
  6+  8565 06 FD                            LD      B, 0xFD
  7+  8567 CD 8F 85                         CALL    ScanKeyPort
  8+  856A C0                               RET     NZ
  9+  856B                                  ; Check row 0xFB (Q, W, E, R, T)
 10+  856B 06 FB                            LD      B, 0xFB
 11+  856D CD 8F 85                         CALL    ScanKeyPort
 12+  8570 C0                               RET     NZ
 13+  8571                                  ; Check row 0xF7 (1, 2, 3, 4, 5)
 14+  8571 06 F7                            LD      B, 0xF7
 15+  8573 CD 8F 85                         CALL    ScanKeyPort
 16+  8576 C0                               RET     NZ
 17+  8577                                  ; Check row 0xEF (0, 9, 8, 7, 6)
 18+  8577 06 EF                            LD      B, 0xEF
 19+  8579 CD 8F 85                         CALL    ScanKeyPort
 20+  857C C0                               RET     NZ
 21+  857D                                  ; Check row 0xDF (P, O, I, U, Y)
 22+  857D 06 DF                            LD      B, 0xDF
 23+  857F CD 8F 85                         CALL    ScanKeyPort
 24+  8582 C0                               RET     NZ
 25+  8583                                  ; Check row 0xBF (ENTER, L, K, J, H)
 26+  8583 06 BF                            LD      B, 0xBF
 27+  8585 CD 8F 85                         CALL    ScanKeyPort
 28+  8588 C0                               RET     NZ
 29+  8589                                  ; Check row 0x7F (SPACE, SYM SHIFT, M, N, B)
 30+  8589 06 7F                            LD      B, 0x7F
 31+  858B CD 8F 85                         CALL    ScanKeyPort
 32+  858E C9                               RET
 33+  858F
 34+  858F              ; scan key port set up in B, SET NZ if a key is pressed on that key port else sets Z
 35+  858F 0E FE        ScanKeyPort:        LD      C, 0xFE         ; Keyboard port
 36+  8591 ED 78                            IN      A, (C)
 37+  8593 E6 1F                            AND     0x1F
 38+  8595 FE 1F                            CP      0x1F
 39+  8597 C9                               RET                     ; NZ set, key pressed, else Z set no key pressed
 40+  8598
# file closed: InputScanUtils.asm
 27   8598                              INCLUDE "Input/WaitPlayerUtils.asm"        ; Include the Wait Player Interaction routines
# file opened: WaitPlayerUtils.asm
  1+  8598              ; Ultra-simple keyboard wait routine
  2+  8598              ; No complex loops - just basic key detection
  3+  8598              WaitForKey:         ; Simple approach: just wait for any key press
  4+  8598 CD 5F 85     WaitLoop:           CALL    ScanAllKeys
  5+  859B 28 FB                            JR      Z, WaitLoop      ; If no key pressed, keep waiting
  6+  859D              KeyPressFound:      ; Simple debounce - small delay
  7+  859D 06 64                            LD      B, 100
  8+  859F 10 FE        Delay:              DJNZ    Delay
  9+  85A1 C9                               RET
 10+  85A2
# file closed: WaitPlayerUtils.asm
 28   85A2
 29   85A2              MathsHelpers:   INCLUDE "Divide/Divide8x8.asm"             ; Include Unified Divide 8-bit routines
# file opened: Divide8x8.asm
  1+  85A2              ; Unified Divide 8x8 operations with performance level
  2+  85A2              ;
  3+  85A2              ; Always call Divide8x8_Unified as the main entry point.
  4+  85A2              ;
  5+  85A2              ; Input: A = dividend, B = divisor, C = performance level
  6+  85A2              ; Output: A = quotient, B = remainder
  7+  85A2              ;
  8+  85A2              ; T-States summary shows:
  9+  85A2              ;
 10+  85A2              ; PERFORMANCE_COMPACT:  ~25-1950 T-states (variable - worst case 255รท1, best case 0รทn or dividend<divisor)
 11+  85A2              ; PERFORMANCE_BALANCED: ~30-1975 T-states (variable - same algorithm as COMPACT but different register usage)
 12+  85A2              ; PERFORMANCE_MAXIMUM:  ~40-1000 T-states (variable - optimized with 2x acceleration, ~50% fewer iterations)
 13+  85A2
 14+  85A2 57           Divide8x8_Unified:      LD      D, A                    ; Save dividend in D so we can check performance levels
 15+  85A3 79                                   LD      A, C                    ; Get Performance Level
 16+  85A4 FE 02                                CP      PERFORMANCE_MAXIMUM
 17+  85A6 CA EC 85                             JP      Z, Divide8x8_Maximum
 18+  85A9 FE 01                                CP      PERFORMANCE_BALANCED
 19+  85AB CA CE 85                             JP      Z, Divide8x8_Balanced
 20+  85AE                                      ; fall through to COMPACT
 21+  85AE 78           Divide8x8_Compact:      LD      A, B                    ; Load divisor into A, check for divide by zero.
 22+  85AF B7                                   OR      A                       ; Check if divisor is zero
 23+  85B0 28 17                                JR      Z, D8x8_Infinity        ; If divide by zero return infinity
 24+  85B2 7A                                   LD      A, D                    ; Restore dividend saved by performance check
 25+  85B3 B7                                   OR      A                       ; Check if dividend is zero
 26+  85B4 28 0E                                JR      Z, D8x8_Zero
 27+  85B6 48                                   LD      C, B                    ; C = divisor (preserve original)
 28+  85B7 06 00                                LD      B, 0                    ; B = quotient counter
 29+  85B9 B9           D8x8_Compact_SubLoop:   CP      C                       ; Compare dividend with divisor
 30+  85BA 38 04                                JR      C, D8x8_Compact_Done    ; If dividend < divisor, done
 31+  85BC 91                                   SUB     C                       ; Subtract divisor from dividend
 32+  85BD 04                                   INC     B                       ; Increment quotient
 33+  85BE 18 F9                                JR      D8x8_Compact_SubLoop    ; Repeat
 34+  85C0              D8x8_Compact_Done:      ; A = remainder, B = quotient
 35+  85C0 4F                                   LD      C, A                    ; C = remainder
 36+  85C1 78                                   LD      A, B                    ; A = quotient
 37+  85C2 41                                   LD      B, C                    ; B = remainder
 38+  85C3 C9                                   RET
 39+  85C4 3E 00        D8x8_Zero:              LD      A, 0                    ; quotient = 0
 40+  85C6 06 00                                LD      B, 0                    ; remainder = 0
 41+  85C8 C9                                   RET
 42+  85C9 3E FF        D8x8_Infinity:          LD      A, 255                  ; quotient = 255
 43+  85CB 06 FF                                LD      B, 255                  ; remainder = 255
 44+  85CD C9                                   RET
 45+  85CE
 46+  85CE              ; Uses simple repeated subtraction for reliability
 47+  85CE 78           Divide8x8_Balanced:     LD      A, B                    ; Load divisor into A
 48+  85CF B7                                   OR      A                       ; Check if divisor is zero
 49+  85D0 28 F7                                JR      Z, D8x8_Infinity        ; If divide by zero return infinity
 50+  85D2 7A                                   LD      A, D                    ; Restore dividend saved by performance check
 51+  85D3 B7                                   OR      A                       ; Check if dividend is zero
 52+  85D4 28 EE                                JR      Z, D8x8_Zero
 53+  85D6 B8                                   CP      B                       ; Check if dividend < divisor
 54+  85D7 38 0F                                JR      C, Div8x8Smaller        ; If so, quotient = 0, remainder = dividend
 55+  85D9 0E 00                                LD      C, 0                    ; Clear quotient counter
 56+  85DB 57                                   LD      D, A                    ; Copy dividend to D
 57+  85DC 7A           Divide8x8Loop:          LD      A, D                    ; Get current dividend
 58+  85DD B8                                   CP      B                       ; Compare with divisor
 59+  85DE 38 05                                JR      C, Divide8x8Done        ; If smaller, we're done
 60+  85E0 90                                   SUB     B                       ; Subtract divisor
 61+  85E1 57                                   LD      D, A                    ; Store back remainder
 62+  85E2 0C                                   INC     C                       ; Increment quotient
 63+  85E3 18 F7                                JR      Divide8x8Loop           ; Continue
 64+  85E5 79           Divide8x8Done:          LD      A, C                    ; Return quotient in A
 65+  85E6 42                                   LD      B, D                    ; Return remainder in B
 66+  85E7 C9                                   RET
 67+  85E8 47           Div8x8Smaller:          LD      B, A                    ; Remainder = dividend
 68+  85E9 3E 00                                LD      A, 0                    ; Quotient = 0
 69+  85EB C9                                   RET
 70+  85EC
 71+  85EC              ; Fast 8-bit รท 8-bit division - Optimized repeated subtraction with larger steps
 72+  85EC 78           Divide8x8_Maximum:      LD      A, B                    ; Load divisor into A
 73+  85ED B7                                   OR      A                       ; Check if divisor is zero
 74+  85EE 28 D9                                JR      Z, D8x8_Infinity        ; If divide by zero return infinity
 75+  85F0 7A                                   LD      A, D                    ; Restore dividend saved by performance check
 76+  85F1 B7                                   OR      A                       ; Check if dividend is zero
 77+  85F2 28 D0                                JR      Z, D8x8_Zero
 78+  85F4 B8                                   CP      B                       ; Check if dividend < divisor
 79+  85F5 38 1F                                JR      C, DivFastSmall         ; If so, quotient = 0, remainder = dividend
 80+  85F7 0E 00                                LD      C, 0                    ; Clear quotient counter
 81+  85F9 57                                   LD      D, A                    ; Copy dividend to D
 82+  85FA 78                                   LD      A, B                    ; Get divisor
 83+  85FB CB 27                                SLA     A                       ; * 2
 84+  85FD 38 0B                                JR      C, DivFast1             ; If overflow, skip 2x optimization
 85+  85FF 5F                                   LD      E, A                    ; Save 2x divisor
 86+  8600 7A           DivFast2Loop:           LD      A, D                    ; Get current dividend
 87+  8601 BB                                   CP      E                       ; Compare with 2x divisor
 88+  8602 38 06                                JR      C, DivFast1             ; If smaller, move to 1x subtraction
 89+  8604
 90+  8604 93                                   SUB     E                       ; Subtract 2x divisor
 91+  8605 57                                   LD      D, A                    ; Store back remainder
 92+  8606 0C                                   INC     C                       ; Increment quotient
 93+  8607 0C                                   INC     C                       ; Increment quotient again (subtracted 2x)
 94+  8608 18 F6                                JR      DivFast2Loop            ; Continue with 2x subtraction
 95+  860A 7A           DivFast1:               LD      A, D                    ; Get current dividend
 96+  860B B8                                   CP      B                       ; Compare with divisor
 97+  860C 38 05                                JR      C, DivFastDone          ; If smaller, we're done
 98+  860E 90                                   SUB     B                       ; Subtract divisor
 99+  860F 57                                   LD      D, A                    ; Store back remainder
100+  8610 0C                                   INC     C                       ; Increment quotient
101+  8611 18 F7                                JR      DivFast1                ; Continue with 1x subtraction
102+  8613 79           DivFastDone:            LD      A, C                    ; Return quotient in A
103+  8614 42                                   LD      B, D                    ; Return remainder in B
104+  8615 C9                                   RET
105+  8616 47           DivFastSmall:           LD      B, A                    ; Remainder = dividend
106+  8617 3E 00                                LD      A, 0                    ; Quotient = 0
107+  8619 C9                                   RET
# file closed: Divide8x8.asm
 30   861A                              INCLUDE "Divide/Divide16x8.asm"            ; Include Unified Divide 16x8 routines
# file opened: Divide16x8.asm
  1+  861A              ; Unified Divide 16x8 operations with performance level
  2+  861A              ;
  3+  861A              ; Always call Divide16x8_Unified as the main entry point.
  4+  861A              ;
  5+  861A              ; Input: HL = dividend (16-bit), B = divisor (8-bit), C = performance level
  6+  861A              ; Output: HL = quotient (16-bit), A = remainder (8-bit)
  7+  861A              ;
  8+  861A              ; T-States summary shows:
  9+  861A              ;
 10+  861A              ; PERFORMANCE_COMPACT:  ~45-1300 T-states (variable - repeated subtraction, worst case 65535รท1)
 11+  861A              ; PERFORMANCE_BALANCED: ~220-280 T-states (fixed - binary long division, consistent 16-bit processing)
 12+  861A              ; PERFORMANCE_MAXIMUM:  ~180-420 T-states (variable - optimized binary division with early exits)
 13+  861A
 14+  861A 79           Divide16x8_Unified:         LD      A, C                        ; Get Performance Level
 15+  861B FE 02                                    CP      PERFORMANCE_MAXIMUM
 16+  861D 28 57                                    JR      Z, Divide16x8_Maximum
 17+  861F FE 01                                    CP      PERFORMANCE_BALANCED
 18+  8621 28 2B                                    JR      Z, Divide16x8_Balanced
 19+  8623                                          ; fall through to COMPACT
 20+  8623              Divide16x8_Compact:         ; Check for zero divisor
 21+  8623 78                                       LD      A, B
 22+  8624 B7                                       OR      A
 23+  8625 28 3E                                    JR      Z, D16x8_Infinity           ; Return infinity for divide by zero
 24+  8627                                          ; Check if dividend is zero
 25+  8627 7C                                       LD      A, H
 26+  8628 B5                                       OR      L
 27+  8629 28 40                                    JR      Z, D16x8_Zero               ; Return 0/0 for zero dividend
 28+  862B                                          ; Check if dividend < divisor
 29+  862B 7C                                       LD      A, H
 30+  862C B7                                       OR      A                           ; Check if high byte is zero
 31+  862D 20 04                                    JR      NZ, D16x8_Compact_DoDiv     ; High byte set, definitely >= divisor
 32+  862F 7D                                       LD      A, L
 33+  8630 B8                                       CP      B
 34+  8631 38 3E                                    JR      C, D16x8_Small              ; dividend < divisor
 35+  8633              D16x8_Compact_DoDiv:        ; Simple repeated subtraction
 36+  8633 11 00 00                                 LD      DE, 0                       ; DE = quotient counter
 37+  8636              D16x8_Compact_Loop:         ; Check if HL >= B (8-bit divisor)
 38+  8636 7C                                       LD      A, H
 39+  8637 B7                                       OR      A                           ; Check if high byte is non-zero
 40+  8638 20 04                                    JR      NZ, D16x8_Compact_CanSub    ; Definitely can subtract
 41+  863A 7D                                       LD      A, L
 42+  863B B8                                       CP      B                           ; Compare low byte with divisor
 43+  863C 38 0D                                    JR      C, D16x8_Compact_Done       ; Cannot subtract, done
 44+  863E              D16x8_Compact_CanSub:       ; Subtract divisor from HL
 45+  863E 7D                                       LD      A, L
 46+  863F 90                                       SUB     B                           ; Subtract divisor from low byte
 47+  8640 6F                                       LD      L, A
 48+  8641 7C                                       LD      A, H
 49+  8642 DE 00                                    SBC     A, 0                        ; Handle borrow from high byte
 50+  8644 67                                       LD      H, A
 51+  8645 1C                                       INC     E                           ; Increment low byte of quotient
 52+  8646 20 EE                                    JR      NZ, D16x8_Compact_Loop      ; Continue if no overflow
 53+  8648 14                                       INC     D                           ; Handle overflow to high byte
 54+  8649 18 EB                                    JR      D16x8_Compact_Loop          ; Continue
 55+  864B              D16x8_Compact_Done:         ; HL = remainder, DE = quotient
 56+  864B 7D                                       LD      A, L                        ; Remainder in A (only 8-bit possible)
 57+  864C EB                                       EX      DE, HL                      ; Quotient in HL
 58+  864D C9                                       RET
 59+  864E
 60+  864E              ; Balanced performance, relatively predictable T state range.
 61+  864E              Divide16x8_Balanced:        ; Check for zero divisor
 62+  864E 78                                       LD      A, B
 63+  864F B7                                       OR      A
 64+  8650 28 13                                    JR      Z, D16x8_Infinity           ; Return infinity for divide by zero
 65+  8652                                          ; Check if dividend is zero
 66+  8652 7C                                       LD      A, H
 67+  8653 B5                                       OR      L
 68+  8654 28 15                                    JR      Z, D16x8_Zero               ; Return 0/0 for zero dividend
 69+  8656 3E 00        Do16x8_Division_Now:        LD      A, 0                        ; Clear remainder
 70+  8658 0E 10                                    LD      C, 16                       ; 16 bits to process
 71+  865A 29           Div16Loop:                  ADD     HL, HL                      ; Shift dividend left
 72+  865B 17                                       RLA                                 ; Rotate remainder left
 73+  865C B8                                       CP      B                           ; Compare remainder with divisor
 74+  865D 38 02                                    JR      C, Div16Next                ; If smaller, skip subtraction
 75+  865F 90                                       SUB     B                           ; Subtract divisor from remainder
 76+  8660 2C                                       INC     L                           ; Set bit in quotient (HL low bit)
 77+  8661 0D           Div16Next:                  DEC     C                           ; Decrement bit counter
 78+  8662 20 F6                                    JR      NZ, Div16Loop               ; Continue if more bits
 79+  8664 C9                                       RET                                 ; Return with quotient in HL, remainder in A
 80+  8665
 81+  8665              ; Shared edge case handlers
 82+  8665 21 FF FF     D16x8_Infinity:             LD      HL, 65535           ; quotient = 65535 (16-bit "infinity")
 83+  8668 3E FF                                    LD      A, 255              ; remainder = 255 (8-bit "infinity")
 84+  866A C9                                       RET
 85+  866B 21 00 00     D16x8_Zero:                 LD      HL, 0               ; quotient = 0
 86+  866E 3E 00                                    LD      A, 0                ; remainder = 0
 87+  8670 C9                                       RET
 88+  8671              D16x8_Small:                ; dividend < divisor, so quotient = 0, remainder = dividend
 89+  8671 7D                                       LD      A, L                ; remainder = original dividend (low byte)
 90+  8672 21 00 00                                 LD      HL, 0               ; quotient = 0
 91+  8675 C9                                       RET
 92+  8676
 93+  8676              ; Maximum performance in most cases. Personally, I would use balanced in games to avoid t state stuttering
 94+  8676              Divide16x8_Maximum:         ; Check for zero divisor
 95+  8676 78                                       LD      A, B
 96+  8677 B7                                       OR      A
 97+  8678 28 EB                                    JR      Z, D16x8_Infinity           ; Return infinity for divide by zero
 98+  867A                                          ; Check if dividend is zero
 99+  867A 7C                                       LD      A, H
100+  867B B5                                       OR      L
101+  867C 28 ED                                    JR      Z, D16x8_Zero               ; Return 0/0 for zero dividend
102+  867E                                          ; Check if dividend is smaller than divisor
103+  867E 7C                                       LD      A, H
104+  867F B7                                       OR      A                           ; Check if high byte is zero
105+  8680 20 04                                    JR      NZ, Divide16x8Fast_LongDivision
106+  8682                                          ; High byte is zero, check if low byte < divisor
107+  8682 7D                                       LD      A, L
108+  8683 B8                                       CP      B
109+  8684 38 37                                    JR      C, Divide16x8Fast_SmallResult
110+  8686              Divide16x8Fast_LongDivision: ; Use optimized repeated subtraction with doubling
111+  8686 11 00 00                                 LD      DE, 0                       ; DE will hold the quotient
112+  8689              Divide16x8Fast_Loop:        ; Check if HL >= B
113+  8689 7C                                       LD      A, H
114+  868A B7                                       OR      A
115+  868B 20 04                                    JR      NZ, Divide16x8Fast_CanSubtract  ; If H != 0, definitely >= B
116+  868D 7D                                       LD      A, L
117+  868E B8                                       CP      B
118+  868F 38 29                                    JR      C, Divide16x8Fast_Done          ; If L < B, we're done
119+  8691              Divide16x8Fast_CanSubtract: ; Try larger subtractions first for speed
120+  8691 48                                       LD      C, B                        ; Save original divisor
121+  8692 3E 01                                    LD      A, 1                        ; Quotient increment
122+  8694                                          ; Check if we can subtract divisor * 2
123+  8694 CB 21                                    SLA     C                           ; C = B * 2
124+  8696 38 0C                                    JR      C, Divide16x8Fast_SingleSub ; Overflow, use single subtraction
125+  8698                                          ; Check if HL >= C (B * 2)
126+  8698 E5                                       PUSH    HL
127+  8699 B7                                       OR      A                           ; Clear carry
128+  869A ED 42                                    SBC     HL, BC                      ; HL = HL - (B * 2), but we only care about C
129+  869C 38 05                                    JR      C, Divide16x8Fast_SingleSubRestore
130+  869E F1                                       POP     AF                          ; Discard saved HL
131+  869F CB 27                                    SLA     A                           ; Double the quotient increment
132+  86A1 18 04                                    JR      Divide16x8Fast_DoSubtraction
133+  86A3              Divide16x8Fast_SingleSubRestore:
134+  86A3 E1                                       POP     HL                          ; Restore HL
135+  86A4 48           Divide16x8Fast_SingleSub:   LD      C, B                        ; Restore original divisor
136+  86A5 3E 01                                    LD      A, 1                        ; Single increment
137+  86A7              Divide16x8Fast_DoSubtraction: ; Subtract C from HL, A times (effectively)
138+  86A7 F5                                       PUSH    AF                          ; Save quotient increment
139+  86A8 7D                                       LD      A, L
140+  86A9 91                                       SUB     C
141+  86AA 6F                                       LD      L, A
142+  86AB 7C                                       LD      A, H
143+  86AC DE 00                                    SBC     A, 0
144+  86AE 67                                       LD      H, A
145+  86AF F1                                       POP     AF                          ; Restore quotient increment
146+  86B0                                          ; Add quotient increment to DE
147+  86B0 4F                                       LD      C, A
148+  86B1 7B                                       LD      A, E
149+  86B2 81                                       ADD     A, C
150+  86B3 5F                                       LD      E, A
151+  86B4 7A                                       LD      A, D
152+  86B5 CE 00                                    ADC     A, 0
153+  86B7 57                                       LD      D, A
154+  86B8 18 CF                                    JR      Divide16x8Fast_Loop
155+  86BA              Divide16x8Fast_Done:        ; HL contains remainder, DE contains quotient
156+  86BA 7D                                       LD      A, L                        ; Remainder in A
157+  86BB EB                                       EX      DE, HL                      ; Quotient in HL
158+  86BC C9                                       RET
159+  86BD              Divide16x8Fast_SmallResult: ; Dividend < divisor, so quotient = 0, remainder = dividend
160+  86BD 7D                                       LD      A, L            ; Remainder = original dividend
161+  86BE 21 00 00                                 LD      HL, 0           ; Quotient = 0
162+  86C1 C9                                       RET
163+  86C2
# file closed: Divide16x8.asm
 31   86C2                              INCLUDE "Multiply/Multiply8x8.asm"         ; Include Unified Multiply 8-bit routines
# file opened: Multiply8x8.asm
  1+  86C2              ; Unified Multiply 8x8 operations with performance level
  2+  86C2              ;
  3+  86C2              ; Always call Multiply8x8_Unified to ensure HL is cleared at start of calculation.
  4+  86C2              ;
  5+  86C2              ; Input: A = multiplicand, B = multiplier, C = performance level,
  6+  86C2              ; Output: HL = result (16-bit)
  7+  86C2              ;
  8+  86C2              ; T-States summary shows:
  9+  86C2              ;
 10+  86C2              ; PERFORMANCE_COMPACT:  ~35-75 T-states (variable, depends on multiplier bit pattern)
 11+  86C2              ; PERFORMANCE_BALANCED: ~160 T-states (fixed, 8 iterations regardless of multiplier)
 12+  86C2              ; PERFORMANCE_MAXIMUM:  ~120 T-states (fixed, unrolled loop with all bit checks)
 13+  86C2              ;
 14+  86C2              ; Although COMPACT appears faster it is unpredictable for speed/game use,
 15+  86C2              ; the other two provide fixed T State counts providing more consistent performance.
 16+  86C2
 17+  86C2 26 00        Multiply8x8_Unified:    LD      H, 0                    ; Clear high byte of result
 18+  86C4 2E 00                                LD      L, 0                    ; Clear low byte of result
 19+  86C6 16 00                                LD      D, 0                    ; Clear high byte of multiplicand
 20+  86C8 5F                                   LD      E, A                    ; Move multiplicand to low byte of DE
 21+  86C9 79                                   LD      A, C                    ; Get Performance Level
 22+  86CA FE 02                                CP      PERFORMANCE_MAXIMUM
 23+  86CC CA F1 86                             JP      Z, Multiply8x8_Unrolled
 24+  86CF FE 01                                CP      PERFORMANCE_BALANCED
 25+  86D1 CA E2 86                             JP      Z, Multiply8x8_Std
 26+  86D4                                      ; fall through to COMPACT
 27+  86D4              Multiply8x8_Compact:    ; optimised for code size
 28+  86D4 B7                                   OR      A                             ; Clear carry flag
 29+  86D5 CB 18        Multiply8_Compact_Loop: RR      B                             ; Rotate multiplier right, bit 0 -> carry
 30+  86D7 30 01                                JR      NC, Multiply8_Compact_Skip
 31+  86D9 19                                   ADD     HL, DE                        ; Add multiplicand (in DE) to result if bit is set.
 32+  86DA EB           Multiply8_Compact_Skip: EX      DE, HL
 33+  86DB 29                                   ADD     HL, HL                        ; Double multiplicand
 34+  86DC EB                                   EX      DE, HL
 35+  86DD 78                                   LD      A, B                          ; Check if more bits to process
 36+  86DE B7                                   OR      A                             ; If B is zero, we're done
 37+  86DF 20 F4                                JR      NZ, Multiply8_Compact_Loop
 38+  86E1 C9                                   RET                                   ; Return with result in HL
 39+  86E2 0E 08        Multiply8x8_Std:        LD      C, 8                          ; 8 bits to process
 40+  86E4 B7                                   OR      A                             ; Clear carry flag
 41+  86E5 CB 18        Multiply8_Std_Loop:     RR      B                             ; Rotate multiplier right, bit 0 -> carry
 42+  86E7 30 01                                JR      NC, Multiply8_Std_NoAdd       ; If carry clear, skip addition
 43+  86E9 19                                   ADD     HL, DE                        ; Add multiplicand (in DE) to result
 44+  86EA EB           Multiply8_Std_NoAdd:    EX      DE, HL                        ; Swap DE and HL to allow use of ADD HL, HL
 45+  86EB 29                                   ADD     HL, HL                        ; Shift multiplicand left (double it)
 46+  86EC EB                                   EX      DE, HL                        ; Swap back
 47+  86ED 0D                                   DEC     C                             ; Decrement bit counter
 48+  86EE 20 F5                                JR      NZ, Multiply8_Std_Loop        ; Continue if more bits to process
 49+  86F0 C9                                   RET                                   ; Return with result in HL
 50+  86F1
 51+  86F1              Multiply8x8_Unrolled:   ; Bit 0 (LSB) - multiplicand ร 1
 52+  86F1 CB 18                                RR      B                             ; Shift multiplier right, bit 0 -> carry
 53+  86F3 30 01                                JR      NC, Multiply8x8_Unrolled_Bit1 ; If carry clear, skip addition
 54+  86F5 19                                   ADD     HL, DE                        ; Add multiplicand ร 1
 55+  86F6              Multiply8x8_Unrolled_Bit1:
 56+  86F6 EB                                   EX      DE, HL                        ; Swap DE and HL
 57+  86F7 29                                   ADD     HL, HL                        ; Double multiplicand (now ร 2)
 58+  86F8 EB                                   EX      DE, HL                        ; Swap back
 59+  86F9 CB 18                                RR      B                             ; Next bit of multiplier
 60+  86FB 30 01                                JR      NC, Multiply8x8_Unrolled_Bit2 ; If carry clear, skip addition
 61+  86FD 19                                   ADD     HL, DE                        ; Add multiplicand ร 2
 62+  86FE
 63+  86FE              Multiply8x8_Unrolled_Bit2:
 64+  86FE EB                                   EX      DE, HL                        ; Swap DE and HL
 65+  86FF 29                                   ADD     HL, HL                        ; Double multiplicand (now ร 4)
 66+  8700 EB                                   EX      DE, HL                        ; Swap back
 67+  8701 CB 18                                RR      B                             ; Next bit of multiplier
 68+  8703 30 01                                JR      NC, Multiply8x8_Unrolled_Bit3 ; If carry clear, skip addition
 69+  8705 19                                   ADD     HL, DE                        ; Add multiplicand ร 4
 70+  8706
 71+  8706              Multiply8x8_Unrolled_Bit3:
 72+  8706 EB                                   EX      DE, HL                        ; Swap DE and HL
 73+  8707 29                                   ADD     HL, HL                        ; Double multiplicand (now ร 8)
 74+  8708 EB                                   EX      DE, HL                        ; Swap back
 75+  8709 CB 18                                RR      B                             ; Next bit of multiplier
 76+  870B 30 01                                JR      NC, Multiply8x8_Unrolled_Bit4 ; If carry clear, skip addition
 77+  870D 19                                   ADD     HL, DE                        ; Add multiplicand ร 8
 78+  870E
 79+  870E              Multiply8x8_Unrolled_Bit4:
 80+  870E EB                                   EX      DE, HL                        ; Swap DE and HL
 81+  870F 29                                   ADD     HL, HL                        ; Double multiplicand (now ร 16)
 82+  8710 EB                                   EX      DE, HL                        ; Swap back
 83+  8711 CB 18                                RR      B                             ; Next bit of multiplier
 84+  8713 30 01                                JR      NC, Multiply8x8_Unrolled_Bit5 ; If carry clear, skip addition
 85+  8715 19                                   ADD     HL, DE                        ; Add multiplicand ร 16
 86+  8716
 87+  8716              Multiply8x8_Unrolled_Bit5:
 88+  8716 EB                                   EX      DE, HL                        ; Swap DE and HL
 89+  8717 29                                   ADD     HL, HL                        ; Double multiplicand (now ร 32)
 90+  8718 EB                                   EX      DE, HL                        ; Swap back
 91+  8719 CB 18                                RR      B                             ; Next bit of multiplier
 92+  871B 30 01                                JR      NC, Multiply8x8_Unrolled_Bit6 ; If carry clear, skip addition
 93+  871D 19                                   ADD     HL, DE                        ; Add multiplicand ร 32
 94+  871E
 95+  871E              Multiply8x8_Unrolled_Bit6:
 96+  871E EB                                   EX      DE, HL                        ; Swap DE and HL
 97+  871F 29                                   ADD     HL, HL                        ; Double multiplicand (now ร 64)
 98+  8720 EB                                   EX      DE, HL                        ; Swap back
 99+  8721 CB 18                                RR      B                             ; Next bit of multiplier
100+  8723 30 01                                JR      NC, Multiply8x8_Unrolled_Bit7 ; If carry clear, skip addition
101+  8725 19                                   ADD     HL, DE                        ; Add multiplicand ร 64
102+  8726
103+  8726              Multiply8x8_Unrolled_Bit7:
104+  8726 EB                                   EX      DE, HL                        ; Swap DE and HL
105+  8727 29                                   ADD     HL, HL                        ; Double multiplicand (now ร 128)
106+  8728 EB                                   EX      DE, HL                        ; Swap back
107+  8729 CB 18                                RR      B                             ; MSB of multiplier
108+  872B D0                                   RET     NC                            ; If carry clear, we're done. Return with result in HL
109+  872C 19                                   ADD     HL, DE                        ; Add multiplicand ร 128
110+  872D C9                                   RET                                     ; Return with result in HL
# file closed: Multiply8x8.asm
 32   872E                              INCLUDE "Multiply/Multiply16x8.asm"        ; Include Unified Multiply 16-bit routines
# file opened: Multiply16x8.asm
  1+  872E              ; Unified Multiply 16x8 operations with performance level
  2+  872E              ;
  3+  872E              ; Always call Multiply16x8_Unified as the main entry point.
  4+  872E              ;
  5+  872E              ; Input: HL = 16 bit multiplicand, B = 8 bit multiplier, C = performance level,
  6+  872E              ; Output: DE:HL = 24-bit result (DE = high 16 bits, HL = low 16 bits)
  7+  872E              ;
  8+  872E              ; T-States summary shows:
  9+  872E              ;
 10+  872E              ; PERFORMANCE_COMPACT:  ~45-380 T-states (variable, depends on multiplier value)
 11+  872E              ; PERFORMANCE_BALANCED: ~180 T-states (fixed, 8 iterations with 16-bit arithmetic)
 12+  872E              ; PERFORMANCE_MAXIMUM:  ~140 T-states (fixed, unrolled loop optimized for speed)
 13+  872E
 14+  872E 79           Multiply16x8_Unified:   LD      A, C                    ; Get Performance Level
 15+  872F FE 02                                CP      PERFORMANCE_MAXIMUM
 16+  8731 CA 80 87                             JP      Z, Multiply16x8_Maximum
 17+  8734 FE 01                                CP      PERFORMANCE_BALANCED
 18+  8736 CA 58 87                             JP      Z, Multiply16x8_Balanced
 19+  8739                                      ; fall through to COMPACT
 20+  8739              Multiply16x8_Compact:   ; Handle zero multiplier quickly
 21+  8739 78                                   LD      A, B
 22+  873A B7                                   OR      A
 23+  873B 28 14                                JR      Z, M16x8_Compact_Zero
 24+  873D                                      ; Simple repeated addition approach (most compact)
 25+  873D                                      ; Save multiplier B in A temporarily
 26+  873D 78                                   LD      A, B                    ; A = multiplier count
 27+  873E                                      ; Set up multiplicand in BC
 28+  873E 4D                                   LD      C, L                    ; BC = multiplicand
 29+  873F 44                                   LD      B, H
 30+  8740                                      ; Initialize result
 31+  8740 11 00 00                             LD      DE, 0                   ; DE = high result
 32+  8743 21 00 00                             LD      HL, 0                   ; HL = low result
 33+  8746
 34+  8746              M16x8_Compact_AddLoop:  ; Simple addition loop
 35+  8746 B7                                   OR      A                      ; Check if multiplier count is zero
 36+  8747 28 07                                JR      Z, M16x8_Compact_AddDone
 37+  8749 3D                                   DEC     A                      ; Decrease count
 38+  874A 09                                   ADD     HL, BC                 ; Add multiplicand to result
 39+  874B 30 F9                                JR      NC, M16x8_Compact_AddLoop ; No carry, continue
 40+  874D 14                                   INC     D                      ; Handle carry to high result (D only)
 41+  874E 18 F6                                JR      M16x8_Compact_AddLoop ; Continue
 42+  8750
 43+  8750 C9           M16x8_Compact_AddDone:  RET
 44+  8751 21 00 00     M16x8_Compact_Zero:     LD      HL, 0
 45+  8754 11 00 00                             LD      DE, 0
 46+  8757 C9                                   RET
 47+  8758
 48+  8758              ; BALANCED performance - fixed timing shift-and-add
 49+  8758              Multiply16x8_Balanced:  ; Check for zero multiplier quickly
 50+  8758 78                                   LD      A, B
 51+  8759 B7                                   OR      A
 52+  875A 28 1D                                JR      Z, M16x8_Balanced_Zero
 53+  875C                                      ; Use standard shift-and-add algorithm
 54+  875C                                      ; Save multiplicand in BC, multiplier in E
 55+  875C 4D                                   LD      C, L                    ; C = low byte of multiplicand
 56+  875D 68                                   LD      L, B                    ; L = multiplier (was in B)
 57+  875E 44                                   LD      B, H                    ; B = high byte of multiplicand
 58+  875F 26 00                                LD      H, 0                    ; H = 0
 59+  8761 11 00 00                             LD      DE, 0                   ; Initialize result high in D
 60+  8764 5D                                   LD      E, L                    ; E = multiplier
 61+  8765 21 00 00                             LD      HL, 0                   ; Clear result low
 62+  8768 CB 3B        M16x8_Balanced_Loop:    SRL     E                       ; Shift multiplier right
 63+  876A 30 04                                JR      NC, M16x8_Balanced_Skip
 64+  876C 09                                   ADD     HL, BC                  ; Add multiplicand
 65+  876D 30 01                                JR      NC, M16x8_Balanced_Skip
 66+  876F 14                                   INC     D                       ; Handle carry
 67+  8770 CB 21        M16x8_Balanced_Skip:    SLA     C                       ; Double multiplicand
 68+  8772 CB 10                                RL      B
 69+  8774 7B                                   LD      A, E
 70+  8775 B7                                   OR      A
 71+  8776 20 F0                                JR      NZ, M16x8_Balanced_Loop
 72+  8778                                      ; Result is already in correct format: DE = high, HL = low
 73+  8778 C9                                   RET
 74+  8779 21 00 00     M16x8_Balanced_Zero:    LD      HL, 0
 75+  877C 11 00 00                             LD      DE, 0
 76+  877F C9                                   RET
 77+  8780
 78+  8780              ; MAXIMUM performance - unrolled for speed
 79+  8780              Multiply16x8_Maximum:   ; Check for zero multiplier quickly
 80+  8780 78                                   LD      A, B
 81+  8781 B7                                   OR      A
 82+  8782 28 69                                JR      Z, M16x8_Maximum_Zero
 83+  8784                                      ; Use unrolled shift-and-add for maximum speed
 84+  8784                                      ; Save multiplicand in BC, multiplier in A
 85+  8784 4D                                   LD      C, L                    ; C = low byte of multiplicand
 86+  8785 78                                   LD      A, B                    ; A = multiplier (was in B)
 87+  8786 44                                   LD      B, H                    ; B = high byte of multiplicand
 88+  8787 11 00 00                             LD      DE, 0                   ; D = carry accumulator, E = 0
 89+  878A 21 00 00                             LD      HL, 0                   ; HL = result accumulator
 90+  878D
 91+  878D                                      ; Unroll all 8 bits for maximum speed
 92+  878D                                      ; Bit 0
 93+  878D CB 0F                                RRC     A                       ; Test bit 0
 94+  878F 30 04                                JR      NC, M16x8_Max_Bit1
 95+  8791 09                                   ADD     HL, BC                  ; Add multiplicand
 96+  8792 30 01                                JR      NC, M16x8_Max_Bit1
 97+  8794 14                                   INC     D                       ; Handle carry
 98+  8795 CB 21        M16x8_Max_Bit1:        SLA     C                       ; Double multiplicand
 99+  8797 CB 10                                RL      B
100+  8799 CB 0F                                RRC     A                       ; Test bit 1
101+  879B 30 04                                JR      NC, M16x8_Max_Bit2
102+  879D 09                                   ADD     HL, BC                  ; Add multiplicand
103+  879E 30 01                                JR      NC, M16x8_Max_Bit2
104+  87A0 14                                   INC     D                       ; Handle carry
105+  87A1 CB 21        M16x8_Max_Bit2:        SLA     C                       ; Double multiplicand
106+  87A3 CB 10                                RL      B
107+  87A5 CB 0F                                RRC     A                       ; Test bit 2
108+  87A7 30 04                                JR      NC, M16x8_Max_Bit3
109+  87A9 09                                   ADD     HL, BC                  ; Add multiplicand
110+  87AA 30 01                                JR      NC, M16x8_Max_Bit3
111+  87AC 14                                   INC     D                       ; Handle carry
112+  87AD CB 21        M16x8_Max_Bit3:        SLA     C                       ; Double multiplicand
113+  87AF CB 10                                RL      B
114+  87B1 CB 0F                                RRC     A                       ; Test bit 3
115+  87B3 30 04                                JR      NC, M16x8_Max_Bit4
116+  87B5 09                                   ADD     HL, BC                  ; Add multiplicand
117+  87B6 30 01                                JR      NC, M16x8_Max_Bit4
118+  87B8 14                                   INC     D                       ; Handle carry
119+  87B9 CB 21        M16x8_Max_Bit4:        SLA     C                       ; Double multiplicand
120+  87BB CB 10                                RL      B
121+  87BD CB 0F                                RRC     A                       ; Test bit 4
122+  87BF 30 04                                JR      NC, M16x8_Max_Bit5
123+  87C1 09                                   ADD     HL, BC                  ; Add multiplicand
124+  87C2 30 01                                JR      NC, M16x8_Max_Bit5
125+  87C4 14                                   INC     D                       ; Handle carry
126+  87C5 CB 21        M16x8_Max_Bit5:        SLA     C                       ; Double multiplicand
127+  87C7 CB 10                                RL      B
128+  87C9 CB 0F                                RRC     A                       ; Test bit 5
129+  87CB 30 04                                JR      NC, M16x8_Max_Bit6
130+  87CD 09                                   ADD     HL, BC                  ; Add multiplicand
131+  87CE 30 01                                JR      NC, M16x8_Max_Bit6
132+  87D0 14                                   INC     D                       ; Handle carry
133+  87D1 CB 21        M16x8_Max_Bit6:        SLA     C                       ; Double multiplicand
134+  87D3 CB 10                                RL      B
135+  87D5 CB 0F                                RRC     A                       ; Test bit 6
136+  87D7 30 04                                JR      NC, M16x8_Max_Bit7
137+  87D9 09                                   ADD     HL, BC                  ; Add multiplicand
138+  87DA 30 01                                JR      NC, M16x8_Max_Bit7
139+  87DC 14                                   INC     D                       ; Handle carry
140+  87DD CB 21        M16x8_Max_Bit7:        SLA     C                       ; Double multiplicand
141+  87DF CB 10                                RL      B
142+  87E1 CB 0F                                RRC     A                       ; Test bit 7
143+  87E3 30 04                                JR      NC, M16x8_Max_Done
144+  87E5 09                                   ADD     HL, BC                  ; Add multiplicand
145+  87E6 30 01                                JR      NC, M16x8_Max_Done
146+  87E8 14                                   INC     D                       ; Handle carry
147+  87E9 1E 00        M16x8_Max_Done:        LD      E, 0                    ; E = 0 (DE = high result)
148+  87EB C9                                   RET                             ; DE:HL = result
149+  87EC C9                                   RET
150+  87ED 21 00 00     M16x8_Maximum_Zero:     LD      HL, 0
151+  87F0 11 00 00                             LD      DE, 0
152+  87F3 C9                                   RET
153+  87F4
# file closed: Multiply16x8.asm
 33   87F4
 34   87F4              RandomHelpers:  INCLUDE "Random/Random8bit.asm"            ; Include 8-bit Random Number Generator - Unified
# file opened: Random8bit.asm
  1+  87F4              ; Unified 8-bit Random number generation routines.
  2+  87F4              ;
  3+  87F4              ; Always call Random8_Unified_Seed to set up the seed and limits for the selected algorithm.
  4+  87F4              ; After setting seed and limit, call Random8_Unified_Next to get each subsequent random number.
  5+  87F4              ;
  6+  87F4              ; Input:  A = upper limit INCLUSIVE (0 to A)
  7+  87F4              ;         B = initial seed value (algorithm dependent)
  8+  87F4              ;         C = algorithm selection (PERFORMANCE_RANDOM_xxx)
  9+  87F4              ; Output: A = random number in range 0 to limit inclusive.
 10+  87F4              ;
 11+  87F4              ; T-States summary shows for each random number generation as:
 12+  87F4              ;
 13+  87F4              ; Random8_Unified_Seed (includes first random generation):
 14+  87F4              ; PERFORMANCE_RANDOM_LCG              - ~75-90 T-states for seed+first call
 15+  87F4              ; PERFORMANCE_RANDOM_LFSR             - ~95-125 T-states for seed+first call
 16+  87F4              ; PERFORMANCE_RANDOM_XORSHIFT         - ~70-85 T-states for seed+first call
 17+  87F4              ; PERFORMANCE_RANDOM_MIDDLESQUARE     - ~145-180 T-states for seed+first call
 18+  87F4              ;
 19+  87F4              ; Random8_Unified_Next (subsequent calls only):
 20+  87F4              ; PERFORMANCE_RANDOM_LCG              - ~45-60 T-states per call
 21+  87F4              ; PERFORMANCE_RANDOM_LFSR             - ~65-95 T-states per call
 22+  87F4              ; PERFORMANCE_RANDOM_XORSHIFT         - ~40-55 T-states per call
 23+  87F4              ; PERFORMANCE_RANDOM_MIDDLESQUARE     - ~115-150 T-states per call
 24+  87F4
 25+  87F4              Random8_Unified_Seed:               ; Set seed and get first random number
 26+  87F4 F5                                   PUSH    AF
 27+  87F5 C5                                   PUSH    BC
 28+  87F6 79                                   LD      A, C                            ; Get algorithm selector
 29+  87F7 FE 01                                CP      PERFORMANCE_RANDOM_LFSR
 30+  87F9 28 10                                JR      Z, Random8_Seed_LFSR
 31+  87FB FE 02                                CP      PERFORMANCE_RANDOM_XORSHIFT
 32+  87FD 28 17                                JR      Z, Random8_Seed_XORShift
 33+  87FF FE 03                                CP      PERFORMANCE_RANDOM_MIDDLESQUARE
 34+  8801 28 1E                                JR      Z, Random8_Seed_MiddleSquare
 35+  8803
 36+  8803                                      ; Fall through to LCG
 37+  8803              Random8_Seed_LCG:
 38+  8803 78                                   LD      A, B                            ; Get seed from B
 39+  8804 32 1C 81                             LD      (RandomSeed8_CurrentSeed), A    ; Store the seed
 40+  8807 C1           RestoreParams:          POP     BC                              ; restore seed and selector
 41+  8808 F1                                   POP     AF                              ; restore limit
 42+  8809 18 21                                JR      Random8_Unified_Next
 43+  880B
 44+  880B              Random8_Seed_LFSR:
 45+  880B 78                                   LD      A, B                            ; Get seed from B
 46+  880C B7                                   OR      A                               ; Check if seed is 0
 47+  880D 20 02                                JR      NZ, LfsrSeed8_ValidSeed
 48+  880F 3E 01                                LD      A, 1                            ; If 0, use 1 (LFSR can't use 0)
 49+  8811 32 1D 81     LfsrSeed8_ValidSeed:    LD      (LfsrSeed8_State), A            ; Store seed
 50+  8814 18 F1                                JR      RestoreParams
 51+  8816
 52+  8816              Random8_Seed_XORShift:
 53+  8816 78                                   LD      A, B                            ; Get seed from B
 54+  8817 B7                                   OR      A                               ; Check if seed is 0
 55+  8818 20 02                                JR      NZ, XorShiftSeed8_ValidSeed
 56+  881A 3E 01                                LD      A, 1                            ; If 0, use 1 (XORShift can't use 0)
 57+  881C              XorShiftSeed8_ValidSeed:
 58+  881C 32 1F 81                             LD      (XorShiftSeed8_State), A        ; Store seed
 59+  881F 18 E6                                JR      RestoreParams
 60+  8821
 61+  8821              Random8_Seed_MiddleSquare:
 62+  8821 78                                   LD      A, B                            ; Get seed from B
 63+  8822 B7                                   OR      A                               ; Check if seed is 0
 64+  8823 20 02                                JR      NZ, MiddleSquareSeed8_ValidSeed
 65+  8825 3E 01                                LD      A, 1                            ; If 0, use 1
 66+  8827              MiddleSquareSeed8_ValidSeed:
 67+  8827 32 1E 81                             LD      (MiddleSquareSeed8_State), A    ; Store seed
 68+  882A 18 DB                                JR      RestoreParams
 69+  882C
 70+  882C              ; Get next random number using previously set seeding, limit can change per call making each algorith useable for multiple ranges as needed.
 71+  882C              ;
 72+  882C              ; Input:  A = upper limit INCLUSIVE (0 to A)
 73+  882C              ;         C = algorithm selection (PERFORMANCE_RANDOM_xxx)
 74+  882C              ; Output: A = random number in range 0 to limit inclusive.
 75+  882C
 76+  882C              Random8_Unified_Next:
 77+  882C 47                                   LD      B, A                            ; Save limit
 78+  882D 79                                   LD      A, C                            ; Get algorithm selector
 79+  882E FE 01                                CP      PERFORMANCE_RANDOM_LFSR
 80+  8830 28 38                                JR      Z, Random8_Next_LFSR
 81+  8832 FE 02                                CP      PERFORMANCE_RANDOM_XORSHIFT
 82+  8834 28 7E                                JR      Z, Random8_Next_XORShift
 83+  8836 FE 03                                CP      PERFORMANCE_RANDOM_MIDDLESQUARE
 84+  8838 CA F5 88                             JP      Z, Random8_Next_MiddleSquare
 85+  883B
 86+  883B                                      ; Fall through to LCG
 87+  883B              Random8_Next_LCG:
 88+  883B 78                                   LD      A, B                            ; Restore limit
 89+  883C C5                                   PUSH    BC                              ; Save registers
 90+  883D E5                                   PUSH    HL
 91+  883E
 92+  883E                                      ; Save the upper limit and convert to exclusive for modulo operation
 93+  883E 4F                                   LD      C, A                            ; C = upper limit (inclusive)
 94+  883F 0C                                   INC     C                               ; C = upper limit + 1 (for modulo)
 95+  8840
 96+  8840                                      ; Generate next random number using LCG formula: next = (seed * 5 + 7) MOD 256
 97+  8840 3A 1C 81                             LD      A, (RandomSeed8_CurrentSeed)    ; Get current seed
 98+  8843
 99+  8843                                      ; Multiply by 5 (seed * 5)
100+  8843 67                                   LD      H, A                            ; Save original seed
101+  8844 87                                   ADD     A, A                            ; seed * 2
102+  8845 87                                   ADD     A, A                            ; seed * 4
103+  8846 84                                   ADD     A, H                            ; seed * 4 + seed = seed * 5
104+  8847                                      ; Add 7
105+  8847 C6 07                                ADD     A, 7                            ; (seed * 5) + 7
106+  8849
107+  8849                                      ; Result is automatically MOD 256 due to 8-bit overflow
108+  8849 32 1C 81                             LD      (RandomSeed8_CurrentSeed), A    ; Store new seed
109+  884C
110+  884C                                      ; Check if upper limit + 1 is 0 or 1 (special cases)
111+  884C 79                                   LD      A, C                            ; Get upper limit + 1
112+  884D FE 01                                CP      1                               ; Compare with 1
113+  884F 28 10                                JR      Z, Random8_ReturnZero           ; If limit+1 is 1 (original limit was 0), return 0
114+  8851 B7                                   OR      A                               ; Check if zero (overflow from 255+1)
115+  8852 28 11                                JR      Z, Random8_ReturnRaw            ; If limit+1 is 0 (original limit was 255), return raw value
116+  8854
117+  8854                                      ; Now we need to get the random number modulo the upper limit + 1
118+  8854                                      ; Use the new seed as our random value
119+  8854 3A 1C 81                             LD      A, (RandomSeed8_CurrentSeed)    ; Get the new random seed
120+  8857 41                                   LD      B, C                            ; B = upper limit + 1 (divisor)
121+  8858
122+  8858                                      ; Simple modulo using repeated subtraction
123+  8858 B8           Random8_ModLoop:        CP      B                               ; Compare A with upper limit + 1
124+  8859 38 03                                JR      C, Random8_Done                 ; If A < limit+1, we're done
125+  885B 90                                   SUB     B                               ; A = A - (limit+1)
126+  885C 18 FA                                JR      Random8_ModLoop                 ; Continue until A < limit+1
127+  885E              Random8_Done:           ; A now contains random number in range 0 to limit (inclusive)
128+  885E E1                                   POP     HL                              ; Restore registers
129+  885F C1                                   POP     BC
130+  8860 C9                                   RET
131+  8861 3E 00        Random8_ReturnZero:     LD      A, 0                            ; Return 0 if limit was 0
132+  8863 18 F9                                JR      Random8_Done
133+  8865              Random8_ReturnRaw:      ; Return raw random value if limit was 255 (covers full 0-255 range)
134+  8865 3A 1C 81                             LD      A, (RandomSeed8_CurrentSeed)    ; Get the raw random value
135+  8868 18 F4                                JR      Random8_Done
136+  886A
137+  886A              ; Get next random number using LFSR algorithm
138+  886A              Random8_Next_LFSR:
139+  886A 78                                   LD      A, B                            ; Restore limit
140+  886B              Lfsr8:                  ; Get next LFSR random number
141+  886B C5                                   PUSH    BC                              ; Save registers
142+  886C 4F                                   LD      C, A                            ; Save limit
143+  886D
144+  886D                                      ; LFSR with polynomial x^8 + x^6 + x^5 + x^4 + 1
145+  886D 3A 1D 81                             LD      A, (LfsrSeed8_State)            ; Get current state
146+  8870 47                                   LD      B, A                            ; Save original
147+  8871
148+  8871                                      ; Calculate feedback bit: bit7 XOR bit5 XOR bit4 XOR bit3
149+  8871 E6 80                                AND     0x80                            ; Isolate bit 7
150+  8873 28 04                                JR      Z, Lfsr8_Bit7Clear
151+  8875 3E 01                                LD      A, 1                            ; Set feedback if bit 7 set
152+  8877 18 02                                JR      Lfsr8_CheckBit5
153+  8879 3E 00        Lfsr8_Bit7Clear:        LD      A, 0                            ; Clear feedback if bit 7 clear
154+  887B 67           Lfsr8_CheckBit5:        LD      H, A                            ; Save feedback so far
155+  887C 78                                   LD      A, B                            ; Get original value
156+  887D E6 20                                AND     0x20                            ; Isolate bit 5
157+  887F 28 04                                JR      Z, Lfsr8_CheckBit4
158+  8881 7C                                   LD      A, H                            ; Get current feedback
159+  8882 EE 01                                XOR     1                               ; XOR with bit 5
160+  8884 67                                   LD      H, A                            ; Save result
161+  8885 78           Lfsr8_CheckBit4:        LD      A, B                            ; Get original value
162+  8886 E6 10                                AND     0x10                            ; Isolate bit 4
163+  8888 28 04                                JR      Z, Lfsr8_CheckBit3
164+  888A 7C                                   LD      A, H                            ; Get current feedback
165+  888B EE 01                                XOR     1                               ; XOR with bit 4
166+  888D 67                                   LD      H, A                            ; Save result
167+  888E 78           Lfsr8_CheckBit3:        LD      A, B                            ; Get original value
168+  888F E6 08                                AND     0x08                            ; Isolate bit 3
169+  8891 28 04                                JR      Z, Lfsr8_Shift
170+  8893 7C                                   LD      A, H                            ; Get current feedback
171+  8894 EE 01                                XOR     1                               ; XOR with bit 3
172+  8896 67                                   LD      H, A                            ; Save result
173+  8897 78           Lfsr8_Shift:            LD      A, B                            ; Get original state
174+  8898 CB 27                                SLA     A                               ; Shift left
175+  889A 44                                   LD      B, H                            ; Get feedback bit
176+  889B B0                                   OR      B                               ; Set bit 0 to feedback
177+  889C 32 1D 81                             LD      (LfsrSeed8_State), A            ; Store new state
178+  889F                                      ; Apply modulo for range
179+  889F 79                                   LD      A, C                            ; Get limit
180+  88A0 B7                                   OR      A                               ; Check if 0
181+  88A1 28 0D                                JR      Z, Lfsr8_ReturnZero
182+  88A3 3C                                   INC     A                               ; Make inclusive
183+  88A4 47                                   LD      B, A                            ; B = divisor
184+  88A5 3A 1D 81                             LD      A, (LfsrSeed8_State)            ; Get random value
185+  88A8 B8           Lfsr8_ModLoop:          CP      B                               ; Compare with limit + 1
186+  88A9 38 03                                JR      C, Lfsr8_Done                   ; If < limit+1, done
187+  88AB 90                                   SUB     B                               ; Subtract limit+1
188+  88AC 18 FA                                JR      Lfsr8_ModLoop                   ; Continue
189+  88AE C1           Lfsr8_Done:             POP     BC                              ; Restore registers
190+  88AF C9                                   RET
191+  88B0 3E 00        Lfsr8_ReturnZero:       LD      A, 0                            ; Return 0 for limit 0
192+  88B2 18 FA                                JR      Lfsr8_Done
193+  88B4
194+  88B4
195+  88B4              ; Get next random number using XOR Shift algorithm
196+  88B4              Random8_Next_XORShift:
197+  88B4 78                                   LD      A, B                            ; Restore limit
198+  88B5 C5                                   PUSH    BC                              ; Save registers
199+  88B6 4F                                   LD      C, A                            ; Save limit
200+  88B7
201+  88B7                                      ; XORShift algorithm with proven 8-bit parameters
202+  88B7 3A 1F 81                             LD      A, (XorShiftSeed8_State)        ; Get current state
203+  88BA
204+  88BA                                      ; Proven variant: x ^= x << 3; x ^= x >> 5; x ^= x << 1
205+  88BA 47                                   LD      B, A                            ; Save original
206+  88BB
207+  88BB                                      ; x ^= x << 3
208+  88BB CB 27                                SLA     A                               ; x << 1
209+  88BD CB 27                                SLA     A                               ; x << 2
210+  88BF CB 27                                SLA     A                               ; x << 3
211+  88C1 A8                                   XOR     B                               ; x ^= (x << 3)
212+  88C2
213+  88C2 47                                   LD      B, A                            ; Save current state
214+  88C3
215+  88C3                                      ; x ^= x >> 5
216+  88C3 CB 3F                                SRL     A                               ; x >> 1
217+  88C5 CB 3F                                SRL     A                               ; x >> 2
218+  88C7 CB 3F                                SRL     A                               ; x >> 3
219+  88C9 CB 3F                                SRL     A                               ; x >> 4
220+  88CB CB 3F                                SRL     A                               ; x >> 5
221+  88CD A8                                   XOR     B                               ; x ^= (x >> 5)
222+  88CE
223+  88CE 47                                   LD      B, A                            ; Save current state
224+  88CF
225+  88CF                                      ; x ^= x << 1
226+  88CF 87                                   ADD     A, A                            ; x << 1
227+  88D0 A8                                   XOR     B                               ; x ^= (x << 1)
228+  88D1                                      ; Ensure non-zero
229+  88D1 B7                                   OR      A                               ; Test if 0
230+  88D2 20 02                                JR      NZ, XorShift8_StateOK
231+  88D4 3E 01                                LD      A, 1                            ; If 0, use 1
232+  88D6 32 1F 81     XorShift8_StateOK:      LD      (XorShiftSeed8_State), A        ; Store new state
233+  88D9
234+  88D9                                      ; Apply modulo for range (optimized for large ranges)
235+  88D9 79                                   LD      A, C                            ; Get limit
236+  88DA B7                                   OR      A                               ; Check if 0
237+  88DB 28 14                                JR      Z, XorShift8_ReturnZero
238+  88DD FE FF                                CP      255                             ; Check if limit is 255 (full range)
239+  88DF 28 0B                                JR      Z, XorShift8_ReturnRaw          ; If 255, return raw value (0-255)
240+  88E1 3C                                   INC     A                               ; Make inclusive (limit + 1)
241+  88E2 47                                   LD      B, A                            ; B = divisor
242+  88E3 3A 1F 81                             LD      A, (XorShiftSeed8_State)        ; Get random value
243+  88E6
244+  88E6                                      ; Simple modulo with safety limit
245+  88E6 B8           XorShift8_ModLoop:      CP      B                               ; Compare with limit + 1
246+  88E7 38 06                                JR      C, XorShift8_Done               ; If < limit+1, done
247+  88E9 90                                   SUB     B                               ; Subtract limit+1
248+  88EA 18 FA                                JR      XorShift8_ModLoop               ; Continue
249+  88EC              XorShift8_ReturnRaw:                                            ; Return raw random value for limit 255
250+  88EC 3A 1F 81                             LD      A, (XorShiftSeed8_State)        ; Get raw random value
251+  88EF C1           XorShift8_Done:         POP     BC                              ; Restore registers
252+  88F0 C9                                   RET
253+  88F1 3E 00        XorShift8_ReturnZero:   LD      A, 0                            ; Return 0 for limit 0
254+  88F3 18 FA                                JR      XorShift8_Done
255+  88F5
256+  88F5              ; Get next random number using Middle Square algorithm
257+  88F5              Random8_Next_MiddleSquare:
258+  88F5 78                                   LD      A, B                            ; Restore limit
259+  88F6 C5                                   PUSH    BC                              ; Save registers
260+  88F7 D5                                   PUSH    DE
261+  88F8 E5                                   PUSH    HL
262+  88F9 4F                                   LD      C, A                            ; Save limit
263+  88FA
264+  88FA                                      ; Square the current state
265+  88FA 3A 1E 81                             LD      A, (MiddleSquareSeed8_State)    ; Get current state
266+  88FD 16 00                                LD      D, 0                            ; Clear high byte
267+  88FF 5F                                   LD      E, A                            ; DE = seed
268+  8900 47                                   LD      B, A                            ; B = multiplier
269+  8901 21 00 00                             LD      HL, 0                           ; Initialize result
270+  8904
271+  8904                                      ; Multiply A * A using repeated addition
272+  8904              MiddleSquare8_MultLoop:
273+  8904 78                                   LD      A, B                            ; Get multiplier
274+  8905 B7                                   OR      A                               ; Check if zero
275+  8906 28 04                                JR      Z, MiddleSquare8_MultDone
276+  8908 19                                   ADD     HL, DE                          ; Add multiplicand
277+  8909 05                                   DEC     B                               ; Decrement counter
278+  890A 18 F8                                JR      MiddleSquare8_MultLoop
279+  890C              MiddleSquare8_MultDone:
280+  890C                                      ; HL now contains seed^2 (16-bit result)
281+  890C                                      ; Extract middle 8 bits: take bits 11-4 of 16-bit result
282+  890C 7D                                   LD      A, L                            ; Get low byte
283+  890D CB 3F                                SRL     A                               ; Shift right 1
284+  890F CB 3F                                SRL     A                               ; Shift right 2
285+  8911 CB 3F                                SRL     A                               ; Shift right 3
286+  8913 CB 3F                                SRL     A                               ; Shift right 4 (now bits 7-4 of L)
287+  8915 47                                   LD      B, A                            ; Save low part
288+  8916 7C                                   LD      A, H                            ; Get high byte
289+  8917 E6 0F                                AND     0x0F                            ; Keep only bits 3-0 of H
290+  8919 CB 27                                SLA     A                               ; Shift left 1
291+  891B CB 27                                SLA     A                               ; Shift left 2
292+  891D CB 27                                SLA     A                               ; Shift left 3
293+  891F CB 27                                SLA     A                               ; Shift left 4 (now bits 3-0 become 7-4)
294+  8921 B0                                   OR      B                               ; Combine with low part
295+  8922
296+  8922 B7                                   OR      A                               ; Check if result is 0
297+  8923 20 02                                JR      NZ, MiddleSquare8_ValidResult
298+  8925 3E 01                                LD      A, 1                            ; If 0, use 1 to avoid stuck state
299+  8927              MiddleSquare8_ValidResult:
300+  8927 32 1E 81                             LD      (MiddleSquareSeed8_State), A    ; Store new state
301+  892A
302+  892A                                      ; Apply modulo for range
303+  892A 79                                   LD      A, C                            ; Get limit
304+  892B B7                                   OR      A                               ; Check if 0
305+  892C 28 0F                                JR      Z, MiddleSquare8_ReturnZero
306+  892E 3C                                   INC     A                               ; Make inclusive
307+  892F 47                                   LD      B, A                            ; B = divisor
308+  8930 3A 1E 81                             LD      A, (MiddleSquareSeed8_State)    ; Get random value
309+  8933 B8           MiddleSquare8_ModLoop:  CP   B                                  ; Compare with limit + 1
310+  8934 38 03                                JR      C, MiddleSquare8_Done           ; If < limit+1, done
311+  8936 90                                   SUB     B                               ; Subtract limit+1
312+  8937 18 FA                                JR      MiddleSquare8_ModLoop           ; Continue
313+  8939 E1           MiddleSquare8_Done:     POP     HL                              ; Restore registers
314+  893A D1                                   POP     DE
315+  893B C1                                   POP     BC
316+  893C C9                                   RET
317+  893D              MiddleSquare8_ReturnZero:
318+  893D 3E 00                                LD      A, 0                            ; Return 0 for limit 0
319+  893F 18 F8                                JR      MiddleSquare8_Done
320+  8941
# file closed: Random8bit.asm
 35   8941                              INCLUDE "Random/Random16bit.asm"           ; Include 16-bit Random Number Generator - Unified
# file opened: Random16bit.asm
  1+  8941              ; Unified 16-bit Random number generation routines.
  2+  8941              ;
  3+  8941              ; Always call Random16_Unified_Seed to set up the seed and limits for the selected algorithm.
  4+  8941              ; After setting seed and limit, call Random16_Unified_Next to get each subsequent random number.
  5+  8941              ;
  6+  8941              ; Input:  HL = upper limit INCLUSIVE (0 to HL)
  7+  8941              ;         BC = initial seed value (algorithm dependent)
  8+  8941              ;         D = algorithm selection (PERFORMANCE_RANDOM_xxx)
  9+  8941              ; Output: HL = random number in range 0 to input HL
 10+  8941              ;
 11+  8941              ; T-States summary shows for each random number generation as:
 12+  8941              ;
 13+  8941              ; Random16_Unified_Seed (includes first random generation):
 14+  8941              ; PERFORMANCE_RANDOM_LCG              - ~140-180 T-states for seed+first call
 15+  8941              ; PERFORMANCE_RANDOM_LFSR             - ~130-165 T-states for seed+first call
 16+  8941              ; PERFORMANCE_RANDOM_XORSHIFT         - ~110-135 T-states for seed+first call
 17+  8941              ; PERFORMANCE_RANDOM_MIDDLESQUARE     - ~400-500 T-states for seed+first call
 18+  8941              ;
 19+  8941              ; Random16_Unified_Next (subsequent calls only):
 20+  8941              ; PERFORMANCE_RANDOM_LCG              - ~110-150 T-states per call
 21+  8941              ; PERFORMANCE_RANDOM_LFSR             - ~100-135 T-states per call
 22+  8941              ; PERFORMANCE_RANDOM_XORSHIFT         - ~80-105 T-states per call
 23+  8941              ; PERFORMANCE_RANDOM_MIDDLESQUARE     - ~370-470 T-states per call
 24+  8941
 25+  8941              Random16_Unified_Seed:               ; Set seed and get first random number
 26+  8941 E5                                   PUSH    HL                              ; Save limit
 27+  8942 C5                                   PUSH    BC                              ; Save seed
 28+  8943 D5                                   PUSH    DE                              ; Save algorithm
 29+  8944 7A                                   LD      A, D                            ; Get algorithm selector
 30+  8945 FE 01                                CP      PERFORMANCE_RANDOM_LFSR
 31+  8947 28 11                                JR      Z, Random16_Seed_LFSR           ; Best For: Cryptographic applications, high-quality randomness, security-critical systems
 32+  8949 FE 02                                CP      PERFORMANCE_RANDOM_XORSHIFT
 33+  894B 28 1A                                JR      Z, Random16_Seed_XORShift       ; Best For: Game engines, real-time applications, procedural generation, particle systems
 34+  894D FE 03                                CP      PERFORMANCE_RANDOM_MIDDLESQUARE
 35+  894F 28 23                                JR      Z, Random16_Seed_MiddleSquare   ; Best For: Educational purposes, historical simulations, demonstrations
 36+  8951
 37+  8951                                      ; Fall through to LCG - Best For: Statistical simulations, large range requirements, scientific applications
 38+  8951 ED 43 20 81  Random16_Seed_LCG:      LD      (RandomSeed16_CurrentSeed), BC  ; Store the seed (16-bit)
 39+  8955 D1           GetTheNextFirstRandom:  POP     DE
 40+  8956 C1                                   POP     BC
 41+  8957 E1                                   POP     HL
 42+  8958 18 27                                JR      Random16_Unified_Next
 43+  895A
 44+  895A              Random16_Seed_LFSR:
 45+  895A 78                                   LD      A, B                            ; Check if seed is 0
 46+  895B B1                                   OR      C
 47+  895C 20 03                                JR      NZ, LfsrSeed16_ValidSeed
 48+  895E 01 D2 04                             LD      BC, 1234                        ; If 0, use a default seed
 49+  8961              LfsrSeed16_ValidSeed:
 50+  8961 ED 43 22 81                          LD      (LfsrSeed16_State), BC          ; Store seed
 51+  8965 18 EE                                JR      GetTheNextFirstRandom
 52+  8967
 53+  8967              Random16_Seed_XORShift:
 54+  8967 78                                   LD      A, B                            ; Check if seed is 0
 55+  8968 B1                                   OR      C
 56+  8969 20 03                                JR      NZ, XorShiftSeed16_ValidSeed
 57+  896B 01 D2 04                             LD      BC, 1234                        ; If 0, use a default seed
 58+  896E              XorShiftSeed16_ValidSeed:
 59+  896E ED 43 26 81                          LD      (XorShiftSeed16_State), BC      ; Store seed
 60+  8972 18 E1                                JR      GetTheNextFirstRandom
 61+  8974
 62+  8974              Random16_Seed_MiddleSquare:
 63+  8974 78                                   LD      A, B                            ; Check if seed is 0
 64+  8975 B1                                   OR      C
 65+  8976 20 03                                JR      NZ, MiddleSquareSeed16_ValidSeed
 66+  8978 01 D2 04                             LD      BC, 1234                        ; If 0, use a default seed
 67+  897B              MiddleSquareSeed16_ValidSeed:
 68+  897B ED 43 24 81                          LD      (MiddleSquareSeed16_State), BC  ; Store seed
 69+  897F 18 D4                                JR      GetTheNextFirstRandom
 70+  8981
 71+  8981              ; Get next random number using previously set seeding, limit can change per call making each algorith useable for multiple ranges as needed.
 72+  8981              ;
 73+  8981              ; Input:  HL = upper limit INCLUSIVE (0 to HL)
 74+  8981              ;         D = algorithm selection (PERFORMANCE_RANDOM_xxx)
 75+  8981              ; Output: HL = random number in range 0 to input HL
 76+  8981
 77+  8981              Random16_Unified_Next:
 78+  8981 7A                                   LD      A, D                            ; Get algorithm selector
 79+  8982 FE 01                                CP      PERFORMANCE_RANDOM_LFSR
 80+  8984 CA 06 8A                             JP      Z, Random16_Next_LFSR
 81+  8987 FE 02                                CP      PERFORMANCE_RANDOM_XORSHIFT
 82+  8989 CA 7E 8A                             JP      Z, Random16_Next_XORShift
 83+  898C FE 03                                CP      PERFORMANCE_RANDOM_MIDDLESQUARE
 84+  898E CA F0 8A                             JP      Z, Random16_Next_MiddleSquare
 85+  8991
 86+  8991                                      ; Fall through to LCG
 87+  8991              Random16_Next_LCG:
 88+  8991 C5                                   PUSH    BC                              ; Save registers
 89+  8992 D5                                   PUSH    DE
 90+  8993                                      ; Save the upper limit for later modulo operation
 91+  8993 E5                                   PUSH    HL                              ; Save limit on stack
 92+  8994
 93+  8994                                      ; Generate next random number using simplified 16-bit LCG
 94+  8994                                      ; Formula: next = (seed * 1103 + 12345) MOD 65536
 95+  8994                                      ; Using smaller multiplier for efficiency while maintaining good distribution
 96+  8994 ED 4B 20 81                          LD      BC, (RandomSeed16_CurrentSeed)  ; Get current seed in BC
 97+  8998                                      ; Multiply BC by 1103 (using shift and add method)
 98+  8998 21 00 00                             LD      HL, 0                           ; Initialize result
 99+  899B 50 59                                LD      DE, BC                          ; Copy seed to DE
100+  899D
101+  899D                                      ; Multiply by 1103 = 1024* + 64* + 15*
102+  899D                                      ; Optimized: First do BC * 64 (shift left 6 times), then continue to get BC * 1024
103+  899D                                      ; Also capture BC * 16 to efficiently calculate BC * 15
104+  899D C5                                   PUSH    BC                              ; Save original BC
105+  899E                                      ; BC * 16: shift BC left 4 times into HL (we'll save this for BC*15 calculation)
106+  899E 3E 04                                LD      A, 4                            ; 4 shifts for *16
107+  89A0 CB 21        Random16_Multiply16:    SLA     C                               ; Shift BC left
108+  89A2 CB 10                                RL      B
109+  89A4 CB 15                                RL      L                               ; Carry into HL
110+  89A6 CB 14                                RL      H
111+  89A8 3D                                   DEC     A
112+  89A9 20 F5                                JR      NZ, Random16_Multiply16
113+  89AB E5                                   PUSH    HL                              ; Save BC*16 result for later
114+  89AC                                      ; Continue shifting 2 more times to get BC * 64 (total 6 shifts)
115+  89AC 3E 02                                LD      A, 2                            ; 2 more shifts for *64
116+  89AE CB 21        Random16_Multiply64:    SLA     C                               ; Shift BC left
117+  89B0 CB 10                                RL      B
118+  89B2 CB 15                                RL      L                               ; Carry into HL
119+  89B4 CB 14                                RL      H
120+  89B6 3D                                   DEC     A
121+  89B7 20 F5                                JR      NZ, Random16_Multiply64
122+  89B9 E5                                   PUSH    HL                              ; Save BC*64 result
123+  89BA                                      ; Continue shifting 4 more times to get BC * 1024 (total 10 shifts)
124+  89BA 3E 04                                LD      A, 4                            ; 4 more shifts for *1024
125+  89BC CB 21        Random16_Multiply1024:  SLA     C                               ; Shift BC left
126+  89BE CB 10                                RL      B
127+  89C0 CB 15                                RL      L                               ; Carry into HL
128+  89C2 CB 14                                RL      H
129+  89C4 3D                                   DEC     A
130+  89C5 20 F5                                JR      NZ, Random16_Multiply1024
131+  89C7                                      ; HL now contains BC*1024
132+  89C7 D1                                   POP     DE                              ; Get BC*64 result
133+  89C8 19                                   ADD     HL, DE                          ; HL = BC*1024 + BC*64
134+  89C9                                      ; Calculate BC * 15 efficiently: BC*16 - BC*1
135+  89C9 D1                                   POP     DE                              ; Get BC*16 result
136+  89CA E5                                   PUSH    HL                              ; Save BC*1024 + BC*64
137+  89CB 62 6B                                LD      HL, DE                          ; HL = BC*16
138+  89CD C1                                   POP     BC                              ; Get original BC from stack
139+  89CE C5                                   PUSH    BC                              ; Save it again for later restore
140+  89CF B7                                   OR      A                               ; Clear carry
141+  89D0 ED 42                                SBC     HL, BC                          ; HL = BC*16 - BC*1 = BC*15
142+  89D2 C1                                   POP     BC                              ; Restore original BC
143+  89D3 D1                                   POP     DE                              ; Get BC*1024 + BC*64 result
144+  89D4 19                                   ADD     HL, DE                          ; HL = BC*1024 + BC*64 + BC*15 = BC*1103
145+  89D5                                      ; Add 12345
146+  89D5 11 39 30                             LD      DE, 12345
147+  89D8 19                                   ADD     HL, DE                          ; HL = BC*1103 + 12345
148+  89D9                                      ; Result is automatically MOD 65536 due to 16-bit overflow
149+  89D9 22 20 81                             LD      (RandomSeed16_CurrentSeed), HL  ; Store new seed
150+  89DC                                      ; Now apply modulo for the requested range
151+  89DC D1                                   POP     DE                              ; Get original limit from stack
152+  89DD 42 4B                                LD      BC, DE                          ; BC = limit
153+  89DF                                      ; Check for special cases
154+  89DF 78                                   LD      A, B                            ; Check high byte of limit
155+  89E0 B1                                   OR      C                               ; OR with low byte
156+  89E1 28 19                                JR      Z, Random16_ReturnZero          ; If limit is 0, return 0
157+  89E3                                      ; Check if limit is 65535 (full range)
158+  89E3 03                                   INC     BC                              ; BC = limit + 1
159+  89E4 78                                   LD      A, B                            ; Check if BC wrapped to 0
160+  89E5 B1                                   OR      C
161+  89E6 28 19                                JR      Z, Random16_ReturnRaw           ; If limit was 65535, return raw
162+  89E8 0B                                   DEC     BC                              ; Restore BC = limit
163+  89E9                                      ; Perform modulo operation using division
164+  89E9                                      ; We need HL MOD (BC + 1)
165+  89E9 03                                   INC     BC                              ; BC = limit + 1 (for inclusive range)
166+  89EA                                      ; Simple 16-bit modulo by repeated subtraction
167+  89EA 7C           Random16_ModLoop:       LD      A, H                            ; Compare HL with BC
168+  89EB B8                                   CP      B                               ; Compare high bytes
169+  89EC 38 0B                                JR      C, Random16_ModDone             ; HL < BC, done
170+  89EE 20 04                                JR      NZ, Random16_ModSub             ; HL > BC, subtract
171+  89F0 7D                                   LD      A, L                            ; High bytes equal, compare low bytes
172+  89F1 B9                                   CP      C
173+  89F2 38 05                                JR      C, Random16_ModDone             ; HL < BC, done
174+  89F4 B7           Random16_ModSub:        OR      A                               ; Clear carry
175+  89F5 ED 42                                SBC     HL, BC                          ; HL = HL - BC
176+  89F7 18 F1                                JR      Random16_ModLoop                ; Continue
177+  89F9 D1           Random16_ModDone:       POP     DE                              ; Restore registers
178+  89FA C1                                   POP     BC
179+  89FB C9                                   RET
180+  89FC 21 00 00     Random16_ReturnZero:    LD     HL, 0                            ; Return 0 for limit 0
181+  89FF 18 F8                                JR      Random16_ModDone
182+  8A01 2A 20 81     Random16_ReturnRaw:     LD     HL, (RandomSeed16_CurrentSeed)   ; Return raw value for limit 65535
183+  8A04 18 F3                                JR      Random16_ModDone
184+  8A06
185+  8A06              Random16_Next_LFSR:
186+  8A06 C5                                   PUSH    BC                              ; Save registers
187+  8A07 D5                                   PUSH    DE
188+  8A08 E5                                   PUSH    HL                              ; Save limit
189+  8A09
190+  8A09                                      ; 16-bit LFSR with polynomial x^16 + x^14 + x^13 + x^11 + 1
191+  8A09                                      ; Taps at bits 15, 13, 12, 10 (counting from 0)
192+  8A09 ED 4B 22 81                          LD      BC, (LfsrSeed16_State)          ; Get current state in BC
193+  8A0D                                      ; Extract the tap bits and XOR them together
194+  8A0D 78                                   LD      A, B                            ; Get high byte
195+  8A0E                                      ; Bit 15 (MSB of B)
196+  8A0E 57                                   LD      D, A                            ; Copy B
197+  8A0F E6 80                                AND     0x80                            ; Mask bit 7 of B (bit 15 of BC)
198+  8A11 5F                                   LD      E, A                            ; Save bit 15 result
199+  8A12                                      ; Bit 13 (bit 5 of B)
200+  8A12 7A                                   LD      A, D                            ; Get B again
201+  8A13 E6 20                                AND     0x20                            ; Mask bit 5 of B (bit 13 of BC)
202+  8A15 CB 27                                SLA     A                               ; Shift to bit 6
203+  8A17 CB 27                                SLA     A                               ; Shift to bit 7 (align with bit 15)
204+  8A19 AB                                   XOR     E                               ; XOR with previous result
205+  8A1A 5F                                   LD      E, A                            ; Save result
206+  8A1B                                      ; Bit 12 (bit 4 of B)
207+  8A1B 7A                                   LD      A, D                            ; Get B again
208+  8A1C E6 10                                AND     0x10                            ; Mask bit 4 of B (bit 12 of BC)
209+  8A1E CB 27                                SLA     A                               ; Shift to bit 5
210+  8A20 CB 27                                SLA     A                               ; Shift to bit 6
211+  8A22 CB 27                                SLA     A                               ; Shift to bit 7 (align with bit 15)
212+  8A24 AB                                   XOR     E                               ; XOR with previous result
213+  8A25 5F                                   LD      E, A                            ; Save result
214+  8A26                                      ; Bit 10 (bit 2 of B)
215+  8A26 7A                                   LD      A, D                            ; Get B again
216+  8A27 E6 04                                AND     0x04                            ; Mask bit 2 of B (bit 10 of BC)
217+  8A29 CB 27                                SLA     A                               ; Shift to bit 3
218+  8A2B CB 27                                SLA     A                               ; Shift to bit 4
219+  8A2D CB 27                                SLA     A                               ; Shift to bit 5
220+  8A2F CB 27                                SLA     A                               ; Shift to bit 6
221+  8A31 CB 27                                SLA     A                               ; Shift to bit 7 (align with bit 15)
222+  8A33 AB                                   XOR     E                               ; XOR with previous result
223+  8A34                                      ; A now contains the feedback bit in bit 7
224+  8A34                                      ; Shift the entire register left and insert feedback bit
225+  8A34 CB 21                                SLA     C                               ; Shift C left
226+  8A36 CB 10                                RL      B                               ; Shift B left with carry from C
227+  8A38                                      ; Insert feedback bit (bit 7 of A) into bit 0 of C
228+  8A38 E6 80                                AND     0x80                            ; Keep only bit 7
229+  8A3A 28 04                                JR      Z, Lfsr16_NoFeedback            ; If 0, don't set bit 0
230+  8A3C CB C1                                SET     0, C                            ; Set bit 0 of C
231+  8A3E 18 02                                JR      Lfsr16_StateUpdate
232+  8A40 CB 81        Lfsr16_NoFeedback:      RES     0, C                            ; Clear bit 0 of C
233+  8A42              Lfsr16_StateUpdate:     ; Ensure we never get 0 (which would break the sequence)
234+  8A42 78                                   LD      A, B
235+  8A43 B1                                   OR      C
236+  8A44 20 03                                JR      NZ, Lfsr16_StateOK
237+  8A46 01 01 00                             LD      BC, 1                           ; If 0, set to 1
238+  8A49 ED 43 22 81  Lfsr16_StateOK:         LD      (LfsrSeed16_State), BC          ; Store new state
239+  8A4D                                      ; Apply modulo for range
240+  8A4D E1                                   POP     HL                              ; Get limit back
241+  8A4E                                      ; Check for special cases
242+  8A4E 7C                                   LD      A, H
243+  8A4F B5                                   OR      L
244+  8A50 28 22                                JR      Z, Lfsr16_ReturnZero            ; If limit is 0, return 0
245+  8A52                                      ; Check if limit is 65535 (full range)
246+  8A52 11 FF FF                             LD      DE, 65535
247+  8A55 B7                                   OR      A                               ; Clear carry
248+  8A56 ED 52                                SBC     HL, DE                          ; Compare HL with 65535
249+  8A58 19                                   ADD     HL, DE                          ; Restore HL
250+  8A59 28 1E                                JR      Z, Lfsr16_ReturnRaw             ; If limit is 65535, return raw
251+  8A5B                                      ; Perform modulo: BC MOD (HL + 1)
252+  8A5B 23                                   INC     HL                              ; HL = limit + 1 (for inclusive)
253+  8A5C 50 59                                LD      DE, BC                          ; DE = random value
254+  8A5E 7A           Lfsr16_ModLoop:         LD      A, D                            ; Compare DE with HL
255+  8A5F BC                                   CP      H                               ; Compare high bytes
256+  8A60 38 0D                                JR      C, Lfsr16_ModDone               ; DE < HL, done
257+  8A62 20 04                                JR      NZ, Lfsr16_ModSub               ; DE > HL, subtract
258+  8A64 7B                                   LD      A, E                            ; High bytes equal, compare low bytes
259+  8A65 BD                                   CP      L
260+  8A66 38 07                                JR      C, Lfsr16_ModDone               ; DE < HL, done
261+  8A68 B7           Lfsr16_ModSub:          OR      A                               ; Clear carry
262+  8A69 EB ED 52 EB                          SBC     DE, HL                          ; DE = DE - HL
263+  8A6D 18 EF                                JR      Lfsr16_ModLoop                  ; Continue
264+  8A6F 62 6B        Lfsr16_ModDone:         LD      HL, DE                          ; Result in HL
265+  8A71 D1           Lfsr16_Exit:            POP     DE                              ; Restore registers
266+  8A72 C1                                   POP     BC
267+  8A73 C9                                   RET
268+  8A74 21 00 00     Lfsr16_ReturnZero:      LD      HL, 0                           ; Return 0 for limit 0
269+  8A77 18 F8                                JR      Lfsr16_Exit
270+  8A79 2A 22 81     Lfsr16_ReturnRaw:       LD      HL, (LfsrSeed16_State)          ; Return raw value for limit 65535
271+  8A7C 18 F3                                JR      Lfsr16_Exit
272+  8A7E
273+  8A7E              Random16_Next_XORShift:
274+  8A7E C5                                   PUSH    BC                              ; Save registers
275+  8A7F D5                                   PUSH    DE
276+  8A80 E5                                   PUSH    HL                              ; Save limit
277+  8A81
278+  8A81                                      ; 16-bit XORShift algorithm: x ^= x << 7; x ^= x >> 9; x ^= x << 8
279+  8A81 ED 4B 26 81                          LD      BC, (XorShiftSeed16_State)      ; Get current state in BC
280+  8A85                                      ; Step 1: x ^= x << 7
281+  8A85 60 69                                LD      HL, BC                          ; Copy BC to HL
282+  8A87 50 59                                LD      DE, BC                          ; Save original in DE
283+  8A89                                      ; Shift HL (copy of BC) left 7 times
284+  8A89 3E 07                                LD      A, 7
285+  8A8B CB 25        XorShift16_ShiftLeft7:  SLA     L                               ; Shift HL left
286+  8A8D CB 14                                RL      H
287+  8A8F 3D                                   DEC     A
288+  8A90 20 F9                                JR      NZ, XorShift16_ShiftLeft7
289+  8A92                                      ; XOR with original: BC = BC ^ (BC << 7)
290+  8A92 79                                   LD      A, C
291+  8A93 AD                                   XOR     L
292+  8A94 4F                                   LD      C, A                            ; C = C ^ L
293+  8A95 78                                   LD      A, B
294+  8A96 AC                                   XOR     H
295+  8A97 47                                   LD      B, A                            ; B = B ^ H
296+  8A98                                      ; Step 2: x ^= x >> 9
297+  8A98 60 69                                LD      HL, BC                          ; Copy current BC to HL
298+  8A9A                                      ; Shift HL right 9 times (more than 8, so will be mostly zeros)
299+  8A9A 3E 09                                LD      A, 9
300+  8A9C CB 3C        XorShift16_ShiftRight9: SRL     H                               ; Shift HL right
301+  8A9E CB 1D                                RR      L
302+  8AA0 3D                                   DEC     A
303+  8AA1 20 F9                                JR      NZ, XorShift16_ShiftRight9
304+  8AA3                                      ; XOR with current: BC = BC ^ (BC >> 9)
305+  8AA3 79                                   LD      A, C
306+  8AA4 AD                                   XOR     L
307+  8AA5 4F                                   LD      C, A                            ; C = C ^ L
308+  8AA6 78                                   LD      A, B
309+  8AA7 AC                                   XOR     H
310+  8AA8 47                                   LD      B, A                            ; B = B ^ H
311+  8AA9                                      ; Step 3: x ^= x << 8
312+  8AA9 60 69                                LD      HL, BC                          ; Copy current BC to HL
313+  8AAB                                      ; Shift HL left 8 times (swap bytes and clear low byte)
314+  8AAB 65                                   LD      H, L                            ; H = L (shift left 8)
315+  8AAC 2E 00                                LD      L, 0                            ; L = 0
316+  8AAE                                      ; XOR with current: BC = BC ^ (BC << 8)
317+  8AAE 79                                   LD      A, C
318+  8AAF AD                                   XOR     L                               ; L is 0, so C unchanged
319+  8AB0 4F                                   LD      C, A
320+  8AB1 78                                   LD      A, B
321+  8AB2 AC                                   XOR     H
322+  8AB3 47                                   LD      B, A                            ; B = B ^ H
323+  8AB4                                      ; Ensure we never get 0 (which would break the sequence)
324+  8AB4 78                                   LD      A, B
325+  8AB5 B1                                   OR      C
326+  8AB6 20 03                                JR      NZ, XorShift16_StateOK
327+  8AB8 01 01 00                             LD      BC, 1                           ; If 0, set to 1
328+  8ABB ED 43 26 81  XorShift16_StateOK:     LD      (XorShiftSeed16_State), BC      ; Store new state
329+  8ABF                                      ; Apply modulo for range
330+  8ABF E1                                   POP     HL                              ; Get limit back
331+  8AC0                                      ; Check for special cases
332+  8AC0 7C                                   LD      A, H
333+  8AC1 B5                                   OR      L
334+  8AC2 28 22                                JR      Z, XorShift16_ReturnZero        ; If limit is 0, return 0
335+  8AC4                                      ; Check if limit is 65535 (full range)
336+  8AC4 11 FF FF                             LD      DE, 65535
337+  8AC7 B7                                   OR      A                               ; Clear carry
338+  8AC8 ED 52                                SBC     HL, DE                          ; Compare HL with 65535
339+  8ACA 19                                   ADD     HL, DE                          ; Restore HL
340+  8ACB 28 1E                                JR      Z, XorShift16_ReturnRaw         ; If limit is 65535, return raw
341+  8ACD                                      ; Perform modulo: BC MOD (HL + 1)
342+  8ACD 23                                   INC     HL                              ; HL = limit + 1 (for inclusive)
343+  8ACE 50 59                                LD      DE, BC                          ; DE = random value
344+  8AD0 7A           XorShift16_ModLoop:     LD      A, D                            ; Compare DE with HL
345+  8AD1 BC                                   CP      H                               ; Compare high bytes
346+  8AD2 38 0D                                JR      C, XorShift16_ModDone           ; DE < HL, done
347+  8AD4 20 04                                JR      NZ, XorShift16_ModSub           ; DE > HL, subtract
348+  8AD6 7B                                   LD      A, E                            ; High bytes equal, compare low bytes
349+  8AD7 BD                                   CP      L
350+  8AD8 38 07                                JR      C, XorShift16_ModDone           ; DE < HL, done
351+  8ADA B7           XorShift16_ModSub:      OR      A                               ; Clear carry
352+  8ADB EB ED 52 EB                          SBC     DE, HL                          ; DE = DE - HL
353+  8ADF 18 EF                                JR      XorShift16_ModLoop              ; Continue
354+  8AE1 62 6B        XorShift16_ModDone:     LD      HL, DE                          ; Result in HL
355+  8AE3 D1           XorShift16_Exit:        POP     DE                              ; Restore registers
356+  8AE4 C1                                   POP     BC
357+  8AE5 C9                                   RET
358+  8AE6 21 00 00     XorShift16_ReturnZero:  LD      HL, 0                           ; Return 0 for limit 0
359+  8AE9 18 F8                                JR      XorShift16_Exit
360+  8AEB 2A 26 81     XorShift16_ReturnRaw:   LD      HL, (XorShiftSeed16_State)      ; Return raw value for limit 65535
361+  8AEE 18 F3                                JR      XorShift16_Exit
362+  8AF0
363+  8AF0              Random16_Next_MiddleSquare:
364+  8AF0 C5                                   PUSH    BC                              ; Save registers
365+  8AF1 D5                                   PUSH    DE
366+  8AF2 DD E5                                PUSH    IX
367+  8AF4 E5                                   PUSH    HL                              ; Save limit
368+  8AF5
369+  8AF5                                      ; Middle Square algorithm: square the current state and extract middle bits
370+  8AF5 ED 4B 24 81                          LD      BC, (MiddleSquareSeed16_State)  ; Get current state
371+  8AF9                                      ; Square BC (16-bit multiplication BC * BC)
372+  8AF9                                      ; Result will be 32-bit in IX:HL
373+  8AF9                                      ; BC * BC using repeated addition method for simplicity
374+  8AF9 DD 21 00 00                          LD      IX, 0                           ; Initialize high part of result
375+  8AFD 21 00 00                             LD      HL, 0                           ; Initialize low part of result
376+  8B00 50 59                                LD      DE, BC                          ; DE = multiplicand (copy of BC)
377+  8B02                                      ; Check if BC is 0 to avoid infinite loop
378+  8B02 78                                   LD      A, B
379+  8B03 B1                                   OR      C
380+  8B04 28 43                                JR      Z, MiddleSquare16_SeedError
381+  8B06              MiddleSquare16_MultiplyLoop:
382+  8B06                                      ; Add DE to IX:HL
383+  8B06 19                                   ADD     HL, DE                          ; Add to low part
384+  8B07 30 02                                JR      NC, MiddleSquare16_NoCarry      ; No carry to high part
385+  8B09 DD 23                                INC     IX                              ; Carry to high part
386+  8B0B 0B           MiddleSquare16_NoCarry: DEC     BC                              ; Decrease counter
387+  8B0C 78                                   LD      A, B                            ; Check if BC is 0
388+  8B0D B1                                   OR      C
389+  8B0E 20 F6                                JR      NZ, MiddleSquare16_MultiplyLoop ; Continue if not 0
390+  8B10                                      ; Extract middle 16 bits from the 32-bit result
391+  8B10                                      ; We have result in IX (high) and HL (low)
392+  8B10                                      ; For middle extraction, we'll use H and L as the middle bytes
393+  8B10                                      ; This gives us a reasonable middle extraction
394+  8B10                                      ; Take bits 23-8 of the 32-bit result as our new 16-bit value
395+  8B10                                      ; This means: new_value = (IX << 8) | H
396+  8B10 DD E5                                PUSH    IX                              ; Get high word
397+  8B12 C1                                   POP     BC                              ; BC = high word
398+  8B13 41                                   LD      B, C                            ; B = low byte of high word
399+  8B14 4C                                   LD      C, H                            ; C = high byte of low word
400+  8B15                                      ; Ensure we don't get stuck in a bad cycle (like 0)
401+  8B15 78                                   LD      A, B
402+  8B16 B1                                   OR      C
403+  8B17 20 03                                JR      NZ, MiddleSquare16_StateOK
404+  8B19 01 2E 16                             LD      BC, 5678                        ; If 0, use another good seed
405+  8B1C ED 43 24 81  MiddleSquare16_StateOK: LD      (MiddleSquareSeed16_State), BC  ; Store new state
406+  8B20                                      ; Apply modulo for range
407+  8B20 E1                                   POP     HL                              ; Get limit back
408+  8B21                                      ; Check for special cases
409+  8B21 7C                                   LD      A, H
410+  8B22 B5                                   OR      L
411+  8B23 28 29                                JR      Z, MiddleSquare16_ReturnZero    ; If limit is 0, return 0
412+  8B25                                      ; Check if limit is 65535 (full range)
413+  8B25 11 FF FF                             LD      DE, 65535
414+  8B28 B7                                   OR      A                               ; Clear carry
415+  8B29 ED 52                                SBC     HL, DE                          ; Compare HL with 65535
416+  8B2B 19                                   ADD     HL, DE                          ; Restore HL
417+  8B2C 28 25                                JR      Z, MiddleSquare16_ReturnRaw     ; If limit is 65535, return raw
418+  8B2E                                      ; Perform modulo: BC MOD (HL + 1)
419+  8B2E 23                                   INC     HL                              ; HL = limit + 1 (for inclusive)
420+  8B2F 50 59                                LD      DE, BC                          ; DE = random value
421+  8B31 7A           MiddleSquare16_ModLoop: LD      A, D                            ; Compare DE with HL
422+  8B32 BC                                   CP      H                               ; Compare high bytes
423+  8B33 38 0D                                JR      C, MiddleSquare16_ModDone       ; DE < HL, done
424+  8B35 20 04                                JR      NZ, MiddleSquare16_ModSub       ; DE > HL, subtract
425+  8B37 7B                                   LD      A, E                            ; High bytes equal, compare low bytes
426+  8B38 BD                                   CP      L
427+  8B39 38 07                                JR      C, MiddleSquare16_ModDone       ; DE < HL, done
428+  8B3B B7           MiddleSquare16_ModSub:  OR      A                               ; Clear carry
429+  8B3C EB ED 52 EB                          SBC     DE, HL                          ; DE = DE - HL
430+  8B40 18 EF                                JR      MiddleSquare16_ModLoop          ; Continue
431+  8B42 62 6B        MiddleSquare16_ModDone: LD      HL, DE                          ; Result in HL
432+  8B44 DD E1        MiddleSquare16_Exit:    POP     IX                              ; Restore registers
433+  8B46 D1                                   POP     DE
434+  8B47 C1                                   POP     BC
435+  8B48 C9                                   RET
436+  8B49              MiddleSquare16_SeedError:
437+  8B49 01 0F 27                             LD      BC, 9999                        ; Emergency seed if we hit 0
438+  8B4C 18 CE                                JR      MiddleSquare16_StateOK
439+  8B4E              MiddleSquare16_ReturnZero:
440+  8B4E 21 00 00                             LD      HL, 0                           ; Return 0 for limit 0
441+  8B51 18 F1                                JR      MiddleSquare16_Exit
442+  8B53              MiddleSquare16_ReturnRaw:
443+  8B53 2A 24 81                             LD      HL, (MiddleSquareSeed16_State)  ; Return raw value for limit 65535
444+  8B56 18 EC                                JR      MiddleSquare16_Exit
445+  8B58
446+  8B58
# file closed: Random16bit.asm
 36   8B58
 37   8B58              ScoreHelpers:   INCLUDE "Scoring/ScoresConvert.asm"        ; Include the 16bit score to display string routines
# file opened: ScoresConvert.asm
  1+  8B58              ; ==============================================================================
  2+  8B58              ; ScoresConvert.asm - Score and Number Display Routines for ZX Spectrum Next
  3+  8B58              ; ==============================================================================
  4+  8B58              ; This file contains routines for converting 16-bit values to ASCII strings
  5+  8B58              ; suitable for display with the PrintString function.
  6+  8B58              ;
  7+  8B58              ; Functions provided:
  8+  8B58              ; - ConvertToDecimal: Converts 16-bit value to zero-terminated ASCII string
  9+  8B58              ;
 10+  8B58              ; Entry points:
 11+  8B58              ; - ConvertToDecimal: Main conversion routine with leading zero control
 12+  8B58              ;
 13+  8B58              ; ==============================================================================
 14+  8B58
 15+  8B58              ; ------------------------------------------------------------------------------
 16+  8B58              ; ConvertToDecimal - Simple and working decimal conversion
 17+  8B58              ; Entry: HL = value, A = leading zero flag, DE = buffer
 18+  8B58              ; Exit: A = length, buffer filled with null-terminated string
 19+  8B58              ; ------------------------------------------------------------------------------
 20+  8B58              ConvertToDecimal:
 21+  8B58                                  ; Initialize state for this conversion
 22+  8B58 F5                               PUSH    AF              ; Save leading zero flag temporarily
 23+  8B59 AF                               XOR     A               ; Clear A
 24+  8B5A 32 17 8C                         LD      (HasStarted), A ; Reset started flag for each call
 25+  8B5D F1                               POP     AF              ; Restore leading zero flag
 26+  8B5E
 27+  8B5E CD 19 8C                         CALL    ClearBuffer     ; Clear 6 bytes, all registers preserved
 28+  8B61
 29+  8B61 E5                               PUSH    HL              ; Save original value
 30+  8B62 D5                               PUSH    DE              ; Save buffer pointer
 31+  8B63 32 18 8C                         LD      (LeadingZeroFlag), A ; Save leading zero flag
 32+  8B66
 33+  8B66                                  ; Special case: value is zero
 34+  8B66 7C                               LD      A, H
 35+  8B67 B5                               OR      L
 36+  8B68 20 1C                            JR      NZ, NonZeroValue
 37+  8B6A
 38+  8B6A                                  ; Handle zero
 39+  8B6A                                  ; Clear buffer first
 40+  8B6A
 41+  8B6A 3A 18 8C                         LD      A, (LeadingZeroFlag)
 42+  8B6D B7                               OR      A
 43+  8B6E 20 0F                            JR      NZ, SingleZero
 44+  8B70
 45+  8B70                                  ; Five zeros
 46+  8B70 3E 30                            LD      A, '0'
 47+  8B72 12                               LD      (DE), A
 48+  8B73 13                               INC     DE
 49+  8B74 12                               LD      (DE), A
 50+  8B75 13                               INC     DE
 51+  8B76 12                               LD      (DE), A
 52+  8B77 13                               INC     DE
 53+  8B78 12                               LD      (DE), A
 54+  8B79 13                               INC     DE
 55+  8B7A 12                               LD      (DE), A
 56+  8B7B 3E 05                            LD      A, 5            ; Length = 5, null terminator already in buffer
 57+  8B7D 18 30                            JR      ExitConvert
 58+  8B7F
 59+  8B7F 3E 30        SingleZero:         LD      A, '0'
 60+  8B81 12                               LD      (DE), A
 61+  8B82 3E 01                            LD      A, 1            ; Length = 1, null terminator already in buffer
 62+  8B84 18 29                            JR      ExitConvert
 63+  8B86
 64+  8B86              NonZeroValue:       ; Convert non-zero value
 65+  8B86 ED 53 15 8C                      LD      (BufferStart), DE
 66+  8B8A AF                               XOR     A               ; Clear A
 67+  8B8B 32 17 8C                         LD      (HasStarted), A ; Initialize HasStarted to 0
 68+  8B8E
 69+  8B8E                                  ; Process each decimal place
 70+  8B8E 11 10 27                         LD      DE, 10000
 71+  8B91 CD B2 8B                         CALL    ProcessDigit
 72+  8B94 11 E8 03                         LD      DE, 1000
 73+  8B97 CD B2 8B                         CALL    ProcessDigit
 74+  8B9A 11 64 00                         LD      DE, 100
 75+  8B9D CD B2 8B                         CALL    ProcessDigit
 76+  8BA0 11 0A 00                         LD      DE, 10
 77+  8BA3 CD B2 8B                         CALL    ProcessDigit
 78+  8BA6 11 01 00                         LD      DE, 1
 79+  8BA9 CD B2 8B                         CALL    ProcessDigit
 80+  8BAC
 81+  8BAC                                  ; Count non-zero bytes in buffer to get length into A
 82+  8BAC CD 02 8C                         CALL    CountBufferLength
 83+  8BAF D1           ExitConvert:        POP     DE
 84+  8BB0 E1                               POP     HL
 85+  8BB1 C9                               RET
 86+  8BB2
 87+  8BB2              ; Process one decimal digit
 88+  8BB2              ; Entry: HL = value, DE = place value (10000,1000,100,10,1)
 89+  8BB2              ; Exit: HL = remainder
 90+  8BB2 AF           ProcessDigit:       XOR     A               ; Digit counter
 91+  8BB3 E5                               PUSH    HL              ; Save original value
 92+  8BB4 B7           DivLoop:            OR      A               ; Clear carry
 93+  8BB5 ED 52                            SBC     HL, DE          ; Subtract place value
 94+  8BB7 38 03                            JR      C, DivDone      ; If negative, we're done
 95+  8BB9 3C                               INC     A               ; Count successful subtraction
 96+  8BBA 18 F8                            JR      DivLoop         ; Continue dividing
 97+  8BBC E1           DivDone:            POP     HL              ; Restore original value
 98+  8BBD F5                               PUSH    AF              ; Save digit count
 99+  8BBE
100+  8BBE                                  ; Calculate remainder: original - (digit * place_value)
101+  8BBE C5                               PUSH    BC              ; Save BC
102+  8BBF 47                               LD      B, A            ; B = digit count
103+  8BC0 B7                               OR      A               ; Test if digit = 0
104+  8BC1 28 07                            JR      Z, RemainderZero ; If digit = 0, remainder = original
105+  8BC3 F5           CalcRemainder:      PUSH    AF              ; Save A since we're about to modify flags
106+  8BC4 B7                               OR      A               ; Clear carry
107+  8BC5 ED 52                            SBC     HL, DE          ; Subtract place value
108+  8BC7 F1                               POP     AF              ; Restore A
109+  8BC8 10 F9                            DJNZ    CalcRemainder   ; Repeat for digit count
110+  8BCA C1           RemainderZero:      POP     BC              ; Restore BC
111+  8BCB F1                               POP     AF              ; Restore digit count
112+  8BCC
113+  8BCC                                  ; A = digit (0-9), HL = remainder
114+  8BCC B7                               OR      A
115+  8BCD 20 18                            JR      NZ, StoreNonZero ; Non-zero digits always stored
116+  8BCF
117+  8BCF                                  ; Zero digit - check if we should store it
118+  8BCF F5                               PUSH    AF              ; Save zero digit
119+  8BD0 3A 17 8C                         LD      A, (HasStarted)
120+  8BD3 B7                               OR      A
121+  8BD4 20 10                            JR      NZ, StoreZeroToo ; If started, store zeros too
122+  8BD6
123+  8BD6                                  ; Not started - check leading zero flag
124+  8BD6 3A 18 8C                         LD      A, (LeadingZeroFlag) ; Get leading zero flag
125+  8BD9 B7                               OR      A
126+  8BDA 28 02                            JR      Z, StoreLeadingZero ; If leading zeros wanted, store it
127+  8BDC
128+  8BDC                                  ; No leading zeros wanted - clean up stack and skip
129+  8BDC F1                               POP     AF              ; Remove zero digit from stack
130+  8BDD C9                               RET                     ; Skip this digit
131+  8BDE
132+  8BDE              StoreLeadingZero:   ; Store leading zero and mark as started
133+  8BDE 3E 01                            LD      A, 1
134+  8BE0 32 17 8C                         LD      (HasStarted), A ; Mark as started for leading zeros too
135+  8BE3 F1                               POP     AF              ; Restore zero digit
136+  8BE4 18 08                            JR      StoreThisDigit  ; Store the zero
137+  8BE6
138+  8BE6 F1           StoreZeroToo:       POP     AF              ; Restore zero digit
139+  8BE7              StoreNonZero:       ; Mark as started and store digit
140+  8BE7 F5                               PUSH    AF
141+  8BE8 3E 01                            LD      A, 1
142+  8BEA 32 17 8C                         LD      (HasStarted), A
143+  8BED F1                               POP     AF
144+  8BEE
145+  8BEE              StoreThisDigit:     ; Store digit A in first zero byte of buffer
146+  8BEE C6 30                            ADD     A, '0'             ; Convert to ASCII
147+  8BF0 E5                               PUSH    HL                 ; Save current value
148+  8BF1 D5                               PUSH    DE                 ; Save place value
149+  8BF2 F5                               PUSH    AF                 ; Save digit
150+  8BF3
151+  8BF3                                  ; Find first zero byte in buffer
152+  8BF3 2A 15 8C                         LD      HL, (BufferStart)  ; Start of buffer
153+  8BF6 7E           FindZeroByte:       LD      A, (HL)            ; Get byte from buffer
154+  8BF7 B7                               OR      A                  ; Check if zero
155+  8BF8 28 03                            JR      Z, FoundZero       ; Found zero byte
156+  8BFA 23                               INC     HL                 ; Next byte
157+  8BFB 18 F9                            JR      FindZeroByte       ; Keep looking
158+  8BFD
159+  8BFD F1           FoundZero:          POP     AF                 ; Restore digit
160+  8BFE 77                               LD      (HL), A            ; Store digit in first zero position
161+  8BFF D1                               POP     DE                 ; Restore place value
162+  8C00 E1                               POP     HL                 ; Restore current value
163+  8C01 C9                               RET
164+  8C02
165+  8C02              ; ------------------------------------------------------------------------------
166+  8C02              ; CountBufferLength - Count non-zero bytes in buffer to determine length
167+  8C02              ; Entry: BufferStart points to buffer
168+  8C02              ; Exit: A = length (number of non-zero bytes)
169+  8C02              ; ------------------------------------------------------------------------------
170+  8C02 E5           CountBufferLength:  PUSH    HL                 ; Preserve HL
171+  8C03 2A 15 8C                         LD      HL, (BufferStart)  ; Start of buffer
172+  8C06 3E 00                            LD      A, 0               ; Length counter
173+  8C08 F5           CountLoop:          PUSH    AF                 ; Save counter
174+  8C09 7E                               LD      A, (HL)            ; Get byte from buffer
175+  8C0A B7                               OR      A                  ; Check if zero
176+  8C0B 28 05                            JR      Z, CountDone       ; Zero byte means end
177+  8C0D F1                               POP     AF                 ; Restore counter
178+  8C0E 3C                               INC     A                  ; Increment length
179+  8C0F 23                               INC     HL                 ; Next byte
180+  8C10 18 F6                            JR      CountLoop          ; Continue counting
181+  8C12 F1           CountDone:          POP     AF                 ; Restore final count
182+  8C13 E1                               POP     HL                 ; Restore HL
183+  8C14 C9                               RET
184+  8C15
185+  8C15              ; Working storage
186+  8C15 00 00        BufferStart:        DW      0
187+  8C17 00           HasStarted:         DB      0
188+  8C18 00           LeadingZeroFlag:    DB      0
189+  8C19
190+  8C19              ; ------------------------------------------------------------------------------
191+  8C19              ; ClearBuffer - Clear 6 bytes of buffer with full register preservation
192+  8C19              ; Entry: DE = buffer pointer
193+  8C19              ; Exit: All registers preserved, buffer cleared to zeros
194+  8C19              ; ------------------------------------------------------------------------------
195+  8C19 F5           ClearBuffer:        PUSH    AF              ; Preserve AF
196+  8C1A E5                               PUSH    HL              ; Preserve HL
197+  8C1B D5                               PUSH    DE              ; Preserve DE
198+  8C1C 62 6B                            LD      HL, DE          ; HL = buffer start
199+  8C1E 36 00                            LD      (HL), 0         ; Clear byte 0
200+  8C20 23                               INC     HL
201+  8C21 36 00                            LD      (HL), 0         ; Clear byte 1
202+  8C23 23                               INC     HL
203+  8C24 36 00                            LD      (HL), 0         ; Clear byte 2
204+  8C26 23                               INC     HL
205+  8C27 36 00                            LD      (HL), 0         ; Clear byte 3
206+  8C29 23                               INC     HL
207+  8C2A 36 00                            LD      (HL), 0         ; Clear byte 4
208+  8C2C 23                               INC     HL
209+  8C2D 36 00                            LD      (HL), 0         ; Clear byte 5
210+  8C2F D1                               POP     DE              ; Restore DE
211+  8C30 E1                               POP     HL              ; Restore HL
212+  8C31 F1                               POP     AF              ; Restore AF
213+  8C32 C9                               RET
214+  8C33
# file closed: ScoresConvert.asm
 38   8C33
 39   8C33              TestPack:       INCLUDE "Testing/TestPackFramework.asm"    ; Include the Test Pack Framework entry points
# file opened: TestPackFramework.asm
  1+  8C33 CD 3E 8D     RunTests:           CALL    TestPackTests
  2+  8C36                                  ; A register now contains result:
  3+  8C36                                  ; 0xFF = all passed
  4+  8C36                                  ; 1-17 = test number that failed
  5+  8C36 C9                               RET
  6+  8C37              AllTestsPassed:     ; Print success message at bottom
  7+  8C37 06 14                            LD      B, 20           ; Row 20
  8+  8C39 0E 00                            LD      C, 0            ; Column 0 (left)
  9+  8C3B CD 50 8C                         CALL    BlankLineAt     ; Blank line at 20
 10+  8C3E 04                               INC     B               ; Move to next line (21)
 11+  8C3F CD 50 8C                         CALL    BlankLineAt     ; Blank line at 21
 12+  8C42 04                               INC     B               ; Move to next line (22)
 13+  8C43 CD 50 8C                         CALL    BlankLineAt     ; Blank line at 22
 14+  8C46 05                               DEC     B               ; Move back to line 21
 15+  8C47 21 FF 8C                         LD      HL, MsgAllPassed
 16+  8C4A CD 60 82                         CALL    PrintStringAt
 17+  8C4D 3E FF                            LD      A, 0xFF         ; Success indicator
 18+  8C4F C9                               RET
 19+  8C50
 20+  8C50 C5           BlankLineAt:        PUSH    BC              ; Save cursor position
 21+  8C51 21 B3 8C                         LD      HL, BlankLine
 22+  8C54 CD 60 82                         CALL    PrintStringAt
 23+  8C57 C1                               POP     BC              ; Restore cursor position (line 21)
 24+  8C58 C9                               RET
 25+  8C59
 26+  8C59              PrintFailed:        ; Print "FAILED" message at current cursor position
 27+  8C59 E5                               PUSH    HL              ; Preserve HL for message description
 28+  8C5A F5                               PUSH    AF              ; A contains test number, so preserve it for middle of message
 29+  8C5B A7 E6 0F                         AND     A, 15           ; Ensure A is in range 0-15 to ensure no scrolling when > 15 tests
 30+  8C5E C6 02                            ADD     A, 2
 31+  8C60 32 B2 8C                         LD      (CurrentLine), A ; Save current line for blanking later
 32+  8C63 47                               LD      B, A            ; Row 2+test number
 33+  8C64 0E 00                            LD      C, 0            ; Column 0 (left)
 34+  8C66 21 EC 8C                         LD      HL, MsgTest
 35+  8C69 CD 60 82                         CALL    PrintStringAt
 36+  8C6C F1                               POP     AF              ; Restore A with test number
 37+  8C6D CD 20 82                         CALL    PrintDecimal
 38+  8C70 E1                               POP     HL              ; Restore HL with message description
 39+  8C71 CD 17 82                         CALL    PrintString
 40+  8C74 21 EF 8C                         LD      HL, MsgFailed
 41+  8C77 CD 17 82                         CALL    PrintString
 42+  8C7A 18 21                            JR      BlankNextLine   ; Blank the next line after the failed test result
 43+  8C7C
 44+  8C7C              PrintPassed:        ; Print "PASSED" message at current cursor position
 45+  8C7C E5                               PUSH    HL              ; Preserve HL for message description
 46+  8C7D F5                               PUSH    AF              ; A contains test number, so preserve it for middle of message
 47+  8C7E A7 E6 0F                         AND     A, 0x0F         ; Ensure A is in range 0-15 to ensure no scrolling when > 15 tests
 48+  8C81 C6 02                            ADD     A, 2
 49+  8C83 32 B2 8C                         LD      (CurrentLine), A ; Save current line for blanking later
 50+  8C86 47                               LD      B, A            ; Row 2 (down from title)
 51+  8C87 0E 00                            LD      C, 0            ; Column 0 (left)
 52+  8C89 21 EC 8C                         LD      HL, MsgTest
 53+  8C8C CD 60 82                         CALL    PrintStringAt
 54+  8C8F F1                               POP     AF              ; Restore A with test number
 55+  8C90 CD 20 82                         CALL    PrintDecimal
 56+  8C93 E1                               POP     HL              ; Restore HL with message description
 57+  8C94 CD 17 82                         CALL    PrintString
 58+  8C97 21 F7 8C                         LD      HL, MsgPassed
 59+  8C9A CD 17 82                         CALL    PrintString
 60+  8C9D
 61+  8C9D 3A B2 8C     BlankNextLine:      LD      A, (CurrentLine)    ; Get current line to blank
 62+  8CA0 3C                               INC     A
 63+  8CA1 47                               LD      B, A            ; Row to blank
 64+  8CA2 0E 00                            LD      C, 0            ; Column 0 (left)
 65+  8CA4 21 B3 8C                         LD      HL, BlankLine
 66+  8CA7 CD 60 82                         CALL    PrintStringAt   ; Blank the line after the test result
 67+  8CAA C9                               RET
 68+  8CAB
 69+  8CAB CD 59 8C     PrintFailedMessage: CALL    PrintFailed
 70+  8CAE 3E 01                            LD      A, 1
 71+  8CB0 B7                               OR      A               ; Set NOT ZERO to allow tests to stop
 72+  8CB1 C9                               RET
 73+  8CB2
 74+  8CB2 00           CurrentLine:        DB      0            ; Current line for blanking after
 75+  8CB3
 76+  8CB3 20 20 20 20  BlankLine:          DB      "                                ", 0 ; Blank line for spacing
 76+  8CB7 20 20 20 20
 76+  8CBB 20 20 20 20
 76+  8CBF 20 20 20 20
 76+  8CC3 20 20 20 20
 76+  8CC7 20 20 20 20
 76+  8CCB 20 20 20 20
 76+  8CCF 20 20 20 20
 76+  8CD3 00
 77+  8CD4 4E 65 78 74  MsgTitle:           DB      "Next Library Test Suite", 0
 77+  8CD8 20 4C 69 62
 77+  8CDC 72 61 72 79
 77+  8CE0 20 54 65 73
 77+  8CE4 74 20 53 75
 77+  8CE8 69 74 65 00
 78+  8CEC 54 2E 00     MsgTest:            DB      "T.", 0
 79+  8CEF 20 3A 20 46  MsgFailed:          DB      " : FAIL", 0
 79+  8CF3 41 49 4C 00
 80+  8CF7 20 3A 20 50  MsgPassed:          DB      " : PASS", 0
 80+  8CFB 41 53 53 00
 81+  8CFF 41 6C 6C 20  MsgAllPassed:       DB      "All tests PASSED!", 0
 81+  8D03 74 65 73 74
 81+  8D07 73 20 50 41
 81+  8D0B 53 53 45 44
 81+  8D0F 21 00
 82+  8D11
 83+  8D11              ; Buffer for conversion results
 84+  8D11 00           ConversionBuffer:   DB      0               ; Most Sig Digit
 85+  8D12 00                               DB      0               ; Second Sig Digit
 86+  8D13 00                               DB      0               ; Third Sig Digit
 87+  8D14 00                               DB      0               ; Fourth Sig Digit
 88+  8D15 00                               DB      0               ; Fifth Sig Digit
 89+  8D16 00                               DB      0               ; always a null terminator
 90+  8D17 00                               DB      0
 91+  8D18
 92+  8D18              ; Number conversion helper to print length and resulting string for debugging purposes.
 93+  8D18              PrintLengthAndString:
 94+  8D18 C5                               PUSH BC
 95+  8D19 F5                               PUSH AF
 96+  8D1A 06 13                            LD      B, 19
 97+  8D1C 0E 00                            LD      C, 0            ; Column 0 (left)
 98+  8D1E C5                               PUSH    BC
 99+  8D1F 21 B3 8C                         LD      HL, BlankLine
100+  8D22 CD 60 82                         CALL    PrintStringAt   ; Blank the line
101+  8D25 C1                               POP     BC
102+  8D26 CD 5B 81                         CALL    SetCursor
103+  8D29 F1                               POP     AF
104+  8D2A F5                               PUSH    AF
105+  8D2B CD 20 82                         CALL    PrintDecimal
106+  8D2E 06 13                            LD      B, 19
107+  8D30 0E 04                            LD      C, 4
108+  8D32 21 11 8D                         LD      HL, ConversionBuffer
109+  8D35 CD 60 82                         CALL    PrintStringAt
110+  8D38 F1                               POP     AF
111+  8D39 C1                               POP     BC
112+  8D3A C9                               RET
113+  8D3B
114+  8D3B              ; Needed to forze Z flag on tests relying on Carry flag
115+  8D3B AF           SetTestPassing:     XOR     A
116+  8D3C B7                               OR      A               ; Sets Z flag
117+  8D3D C9                               RET
# file closed: TestPackFramework.asm
 40   8D3E                              INCLUDE "Testing/TestPackTests.asm"        ; Include the Test Pack Tests Executor
# file opened: TestPackTests.asm
  1+  8D3E
  2+  8D3E CD 28 81     TestPackTests:      CALL    ClearScreen     ; Clear the screen
  3+  8D41                                  ; Print title at top
  4+  8D41 06 00                            LD      B, 0            ; Row 0 (top)
  5+  8D43 0E 00                            LD      C, 0            ; Column 0 (left)
  6+  8D45 21 D4 8C                         LD      HL, MsgTitle
  7+  8D48 CD 60 82                         CALL    PrintStringAt
  8+  8D4B                                  ; Position cursor for test results (2 lines below title)
  9+  8D4B 06 03                            LD      B, 3            ; Row 3 (leaving space after title)
 10+  8D4D 0E 00                            LD      C, 0            ; Column 0 (left)
 11+  8D4F CD 5B 81                         CALL    SetCursor
 12+  8D52              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 13+  8D52 CD A2 8E                         CALL    TestCase001     ; Test case 1: 5 ร 3 = 15
 14+  8D55 C0                               RET     NZ              ; If test failed, return
 15+  8D56 3E 01                            LD      A, 1            ; Test number
 16+  8D58 CD 7C 8C                         CALL    PrintPassed
 17+  8D5B CD C8 8E                         CALL    TestCase002     ; Test case 2: 12 ร 8 = 96
 18+  8D5E C0                               RET     NZ              ; If test failed, return
 19+  8D5F 3E 02                            LD      A, 2            ; Test number
 20+  8D61 CD 7C 8C                         CALL    PrintPassed
 21+  8D64 CD EF 8E                         CALL    TestCase003     ; Test case 3: 15 ร 17 = 255
 22+  8D67 C0                               RET     NZ              ; If test failed, return
 23+  8D68 3E 03                            LD      A, 3            ; Test number
 24+  8D6A CD 7C 8C                         CALL    PrintPassed
 25+  8D6D CD 18 8F                         CALL    TestCase004     ; Test case 4: 0 ร 123 = 0
 26+  8D70 C0                               RET     NZ              ; If test failed, return
 27+  8D71 3E 04                            LD      A, 4            ; Test number
 28+  8D73 CD 7C 8C                         CALL    PrintPassed
 29+  8D76 CD 3B 8F                         CALL    TestCase005     ; Test case 5: 16 ร 16 = 256
 30+  8D79 C0                               RET     NZ              ; If test failed, return
 31+  8D7A 3E 05                            LD      A, 5            ; Test number
 32+  8D7C CD 7C 8C                         CALL    PrintPassed
 33+  8D7F              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 34+  8D7F CD 64 8F                         CALL    TestCase006     ; Test case 6: 45 รท 7 = 6 remainder 3
 35+  8D82 C0                               RET     NZ              ; If test failed, return
 36+  8D83 3E 06                            LD      A, 6            ; Test number
 37+  8D85 CD 7C 8C                         CALL    PrintPassed
 38+  8D88 CD 8D 8F                         CALL    TestCase007     ; Test case 7: 100 รท 8 = 12 remainder 4
 39+  8D8B C0                               RET     NZ              ; If test failed, return
 40+  8D8C 3E 07                            LD      A, 7            ; Test number
 41+  8D8E CD 7C 8C                         CALL    PrintPassed
 42+  8D91 CD B8 8F                         CALL    TestCase008     ; Test case 8: 255 รท 15 = 17 remainder 0
 43+  8D94 C0                               RET     NZ              ; If test failed, return
 44+  8D95 3E 08                            LD      A, 8            ; Test number
 45+  8D97 CD 7C 8C                         CALL    PrintPassed
 46+  8D9A CD E4 8F                         CALL    TestCase009     ; Test case 9: 50 รท 200 = 0 remainder 50 (dividend < divisor)
 47+  8D9D C0                               RET     NZ              ; If test failed, return
 48+  8D9E 3E 09                            LD      A, 9            ; Test number
 49+  8DA0 CD 7C 8C                         CALL    PrintPassed
 50+  8DA3              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 51+  8DA3 CD 10 90                         CALL    TestCase010     ; Test case 10: 5000 รท 13 = 384 remainder 8 (16-bit division)
 52+  8DA6 C0                               RET     NZ              ; If test failed, return
 53+  8DA7 3E 0A                            LD      A, 10           ; Test number
 54+  8DA9 CD 7C 8C                         CALL    PrintPassed
 55+  8DAC CD 46 90                         CALL    TestCase011     ; Test case 11: 1000 ร 50 = 50000 (16x8 multiplication)
 56+  8DAF C0                               RET     NZ              ; If test failed, return
 57+  8DB0 3E 0B                            LD      A, 11           ; Test number
 58+  8DB2 CD 7C 8C                         CALL    PrintPassed
 59+  8DB5 CD 7D 90                         CALL    TestCase012     ; Test case 12: 200 ร 25 = 5000 (16x8 fast multiplication)
 60+  8DB8 C0                               RET     NZ              ; If test failed, return
 61+  8DB9 3E 0C                            LD      A, 12           ; Test number
 62+  8DBB CD 7C 8C                         CALL    PrintPassed
 63+  8DBE CD B2 90                         CALL    TestCase013     ; Test case 13: 5000 รท 25 = 200 remainder 0 (16x8 fast division)
 64+  8DC1 C0                               RET     NZ              ; If test failed, return
 65+  8DC2 3E 0D                            LD      A, 13           ; Test number
 66+  8DC4 CD 7C 8C                         CALL    PrintPassed
 67+  8DC7              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 68+  8DC7 CD EA 90                         CALL    TestCase014     ; Test case 14: Random number generator validation LCG
 69+  8DCA C0                               RET     NZ              ; If test failed, return
 70+  8DCB 3E 0E                            LD      A, 14           ; Test number
 71+  8DCD CD 7C 8C                         CALL    PrintPassed
 72+  8DD0 CD 2D 91                         CALL    TestCase015     ; Test case 15: Random number generator validation XORShift
 73+  8DD3 C0                               RET     NZ              ; If test failed, return
 74+  8DD4 3E 0F                            LD      A, 15           ; Test number
 75+  8DD6 CD 7C 8C                         CALL    PrintPassed
 76+  8DD9 CD 70 91                         CALL    TestCase016     ; Test case 16: LFSR random number generator
 77+  8DDC C0                               RET     NZ              ; If test failed, return
 78+  8DDD 3E 10                            LD      A, 16           ; Test number
 79+  8DDF CD 7C 8C                         CALL    PrintPassed
 80+  8DE2 CD A1 91                         CALL    TestCase017     ; Test case 17: Middle Square random number generator
 81+  8DE5 C0                               RET     NZ              ; If test failed, return
 82+  8DE6 3E 11                            LD      A, 17           ; Test number
 83+  8DE8 CD 7C 8C                         CALL    PrintPassed
 84+  8DEB              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 85+  8DEB CD D8 91                         CALL    TestCase018     ; Test case 18: Random number generator validation LCG 16 bit
 86+  8DEE C0                               RET     NZ              ; If test failed, return
 87+  8DEF 3E 12                            LD      A, 18           ; Test number
 88+  8DF1 CD 7C 8C                         CALL    PrintPassed
 89+  8DF4 CD 21 92                         CALL    TestCase019     ; Test case 19: Random number generator validation XORShift 16 bit
 90+  8DF7 C0                               RET     NZ              ; If test failed, return
 91+  8DF8 3E 13                            LD      A, 19           ; Test number
 92+  8DFA CD 7C 8C                         CALL    PrintPassed
 93+  8DFD CD 5F 92                         CALL    TestCase020     ; Test case 20: Random number generator validation LFSR 16 bit
 94+  8E00 C0                               RET     NZ              ; If test failed, return
 95+  8E01 3E 14                            LD      A, 20           ; Test number
 96+  8E03 CD 7C 8C                         CALL    PrintPassed
 97+  8E06 CD 9E 92                         CALL    TestCase021     ; Test case 21: Random number generator validation Middle Square 16 bit
 98+  8E09 C0                               RET     NZ              ; If test failed, return
 99+  8E0A 3E 15                            LD      A, 21           ; Test number
100+  8E0C CD 7C 8C                         CALL    PrintPassed
101+  8E0F              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
102+  8E0F CD E3 92                         CALL    TestCase022     ; Test case 22: Convert 0 without leading zeros
103+  8E12 C0                               RET     NZ              ; If test failed, return
104+  8E13 3E 16                            LD      A, 22           ; Test number
105+  8E15 CD 7C 8C                         CALL    PrintPassed
106+  8E18 CD 12 93                         CALL    TestCase023     ; Test case 23: Convert 0 with leading zeros
107+  8E1B C0                               RET     NZ              ; If test failed, return
108+  8E1C 3E 17                            LD      A, 23           ; Test number
109+  8E1E CD 7C 8C                         CALL    PrintPassed
110+  8E21 CD 50 93                         CALL    TestCase024     ; Test case 24: Convert 1 without leading zeros
111+  8E24 C0                               RET     NZ              ; If test failed, return
112+  8E25 3E 18                            LD      A, 24           ; Test number
113+  8E27 CD 7C 8C                         CALL    PrintPassed
114+  8E2A CD 7F 93                         CALL    TestCase025     ; Test case 25: Convert 1 with leading zeros
115+  8E2D C0                               RET     NZ              ; If test failed, return
116+  8E2E 3E 19                            LD      A, 25           ; Test number
117+  8E30 CD 7C 8C                         CALL    PrintPassed
118+  8E33 CD C3 93                         CALL    TestCase026     ; Test case 26: Convert 123 without leading zeros
119+  8E36 C0                               RET     NZ              ; If test failed, return
120+  8E37 3E 1A                            LD      A, 26           ; Test number
121+  8E39 CD 7C 8C                         CALL    PrintPassed
122+  8E3C CD 00 94                         CALL    TestCase027     ; Test case 27: Convert 123 with leading zeros
123+  8E3F C0                               RET     NZ              ; If test failed, return
124+  8E40 3E 1B                            LD      A, 27           ; Test number
125+  8E42 CD 7C 8C                         CALL    PrintPassed
126+  8E45 CD 54 94                         CALL    TestCase028     ; Test case 28: Convert 9999 without leading zeros
127+  8E48 C0                               RET     NZ              ; If test failed, return
128+  8E49 3E 1C                            LD      A, 28           ; Test number
129+  8E4B CD 7C 8C                         CALL    PrintPassed
130+  8E4E CD 8A 94                         CALL    TestCase029     ; Test case 29: Convert 65535 without leading zeros
131+  8E51 C0                               RET     NZ              ; If test failed, return
132+  8E52 3E 1D                            LD      A, 29           ; Test number
133+  8E54 CD 7C 8C                         CALL    PrintPassed
134+  8E57 CD D5 94                         CALL    TestCase030     ; Test case 30: Convert 12345 in both modes
135+  8E5A C0                               RET     NZ              ; If test failed, return
136+  8E5B 3E 1E                            LD      A, 30           ; Test number
137+  8E5D CD 7C 8C                         CALL    PrintPassed
138+  8E60              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Unification Refactor extra test cases
139+  8E60 CD 33 95                         CALL    TestCase031     ; Test case 31: Compact Multiply 8x8
140+  8E63 C0                               RET     NZ              ; If test failed, return
141+  8E64 3E 1F                            LD      A, 31           ; Test number
142+  8E66 CD 7C 8C                         CALL    PrintPassed
143+  8E69 CD 59 95                         CALL    TestCase032     ; Test case 32: Compact Multiply 16x8
144+  8E6C C0                               RET     NZ              ; If test failed, return
145+  8E6D 3E 20                            LD      A, 32           ; Test number
146+  8E6F CD 7C 8C                         CALL    PrintPassed
147+  8E72 CD 90 95                         CALL    TestCase033     ; Test case 33: Compact Multiply 16x8 - Large Result
148+  8E75 C0                               RET     NZ              ; If test failed, return
149+  8E76 3E 21                            LD      A, 33           ; Test number
150+  8E78 CD 7C 8C                         CALL    PrintPassed
151+  8E7B CD CE 95                         CALL    TestCase034     ; Test case 34: Balanced Multiply 16x8 - Large Result
152+  8E7E C0                               RET     NZ              ; If test failed, return
153+  8E7F 3E 22                            LD      A, 34           ; Test number
154+  8E81 CD 7C 8C                         CALL    PrintPassed
155+  8E84 CD 0B 96                         CALL    TestCase035     ; Test case 35: Maximum Multiply 16x8 - Large Result
156+  8E87 C0                               RET     NZ              ; If test failed, return
157+  8E88 3E 23                            LD      A, 35           ; Test number
158+  8E8A CD 7C 8C                         CALL    PrintPassed
159+  8E8D CD 48 96                         CALL    TestCase036     ; Test case 36: Compact Divide 8x8
160+  8E90 C0                               RET     NZ              ; If test failed, return
161+  8E91 3E 24                            LD      A, 36           ; Test number
162+  8E93 CD 7C 8C                         CALL    PrintPassed
163+  8E96 CD 71 96                         CALL    TestCase037     ; Test case 37: Compact Divide 16x8
164+  8E99 C0                               RET     NZ              ; If test failed, return
165+  8E9A 3E 25                            LD      A, 37           ; Test number
166+  8E9C CD 7C 8C                         CALL    PrintPassed
167+  8E9F              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
168+  8E9F C3 37 8C                         JP      AllTestsPassed  ; If we reach here, all tests passed
169+  8EA2
# file closed: TestPackTests.asm
 41   8EA2                              INCLUDE "Testing/TestCases.asm"            ; Include all test cases
# file opened: TestCases.asm
  1+  8EA2                              INCLUDE "TestCase001.asm"  ; Multiply 8x8 - PERFORMANCE_BALANCED
# file opened: TestCase001.asm
  1++ 8EA2              TestCase001:        ; Test case 1: 5 ร 3 = 15
  2++ 8EA2 3E 05                            LD      A, 5            ; Multiplicand
  3++ 8EA4 06 03                            LD      B, 3            ; Multiplier
  4++ 8EA6 0E 01                            LD      C, PERFORMANCE_BALANCED
  5++ 8EA8 CD C2 86                         CALL    Multiply8x8_Unified
  6++ 8EAB
  7++ 8EAB                                  ; Result should be 15 in HL
  8++ 8EAB 11 0F 00                         LD      DE, 15          ; Expected result
  9++ 8EAE B7                               OR      A               ; Clear carry
 10++ 8EAF ED 52                            SBC     HL, DE          ; Compare result with expected
 11++ 8EB1 21 BA 8E                         LD      HL, MsgTestCase001
 12++ 8EB4 C8                               RET     Z               ; Z set is test passed, else test failed.
 13++ 8EB5 3E 01        Test1Failed:        LD      A, 1            ; Test number
 14++ 8EB7 C3 AB 8C                         JP      PrintFailedMessage
 15++ 8EBA
 16++ 8EBA 20 28 35 20  MsgTestCase001:     DB      " (5 x 3 = 15)", 0
 16++ 8EBE 78 20 33 20
 16++ 8EC2 3D 20 31 35
 16++ 8EC6 29 00
 17++ 8EC8
# file closed: TestCase001.asm
  2+  8EC8                              INCLUDE "TestCase002.asm"  ; Multiply 8x8 - PERFORMANCE_MAXIMUM
# file opened: TestCase002.asm
  1++ 8EC8              TestCase002:        ; Test case 2: 12 ร 8 = 96
  2++ 8EC8 3E 0C                            LD      A, 12               ; Multiplicand
  3++ 8ECA 06 08                            LD      B, 8                ; Multiplier
  4++ 8ECC 0E 02                            LD      C, PERFORMANCE_MAXIMUM
  5++ 8ECE CD C2 86                         CALL    Multiply8x8_Unified
  6++ 8ED1
  7++ 8ED1                                  ; Result should be 96 in HL
  8++ 8ED1 11 60 00                         LD      DE, 96              ; Expected result
  9++ 8ED4 B7                               OR      A                   ; Clear carry
 10++ 8ED5 ED 52                            SBC     HL, DE              ; Compare result with expected
 11++ 8ED7 21 E0 8E                         LD      HL, MsgTestCase002
 12++ 8EDA C8                               RET     Z                   ; Z set is test passed, else test failed.
 13++ 8EDB 3E 02        Test2Failed:        LD      A, 2                ; Test number
 14++ 8EDD C3 AB 8C                         JP      PrintFailedMessage
 15++ 8EE0
 16++ 8EE0 20 28 31 32  MsgTestCase002:     DB      " (12 x 8 = 96)", 0
 16++ 8EE4 20 78 20 38
 16++ 8EE8 20 3D 20 39
 16++ 8EEC 36 29 00
 17++ 8EEF
# file closed: TestCase002.asm
  3+  8EEF                              INCLUDE "TestCase003.asm"  ; Multiply 8x8 - PERFORMANCE_BALANCED
# file opened: TestCase003.asm
  1++ 8EEF              TestCase003:        ; Test case 3: 15 ร 17 = 255
  2++ 8EEF 3E 0F                            LD      A, 15           ; Multiplicand
  3++ 8EF1 06 11                            LD      B, 17           ; Multiplier
  4++ 8EF3 0E 01                            LD      C, PERFORMANCE_BALANCED
  5++ 8EF5 CD C2 86                         CALL    Multiply8x8_Unified
  6++ 8EF8
  7++ 8EF8                                  ; Result should be 255 in HL
  8++ 8EF8 11 FF 00                         LD      DE, 255         ; Expected result
  9++ 8EFB B7                               OR      A               ; Clear carry
 10++ 8EFC ED 52                            SBC     HL, DE          ; Compare result with expected
 11++ 8EFE 21 07 8F                         LD      HL, MsgTestCase003
 12++ 8F01 C8                               RET     Z               ; Z set is test passed, else test failed.
 13++ 8F02 3E 03        Test3Failed:        LD      A, 3            ; Test number
 14++ 8F04 C3 AB 8C                         JP      PrintFailedMessage
 15++ 8F07
 16++ 8F07 20 28 31 35  MsgTestCase003:     DB      " (15 x 17 = 255)", 0
 16++ 8F0B 20 78 20 31
 16++ 8F0F 37 20 3D 20
 16++ 8F13 32 35 35 29
 16++ 8F17 00
 17++ 8F18
# file closed: TestCase003.asm
  4+  8F18                              INCLUDE "TestCase004.asm"  ; Multiply 8x8 - PERFORMANCE_BALANCED
# file opened: TestCase004.asm
  1++ 8F18              TestCase004:        ; Test case 4: 0 ร 123 = 0
  2++ 8F18 3E 00                            LD      A, 0            ; Multiplicand
  3++ 8F1A 06 7B                            LD      B, 123          ; Multiplier
  4++ 8F1C 0E 02                            LD      C, PERFORMANCE_MAXIMUM
  5++ 8F1E CD C2 86                         CALL    Multiply8x8_Unified
  6++ 8F21
  7++ 8F21                                  ; Result should be 0 in HL
  8++ 8F21 7C                               LD      A, H            ; Check high byte
  9++ 8F22 B5                               OR      L               ; OR with low byte
 10++ 8F23 21 2C 8F                         LD      HL, MsgTestCase004
 11++ 8F26 C8                               RET     Z               ; Z set is test passed, else test failed.
 12++ 8F27 3E 04        Test4Failed:        LD      A, 4            ; Test number
 13++ 8F29 C3 AB 8C                         JP      PrintFailedMessage
 14++ 8F2C
 15++ 8F2C 20 28 30 20  MsgTestCase004:     DB      " (0 x 123 = 0)", 0
 15++ 8F30 78 20 31 32
 15++ 8F34 33 20 3D 20
 15++ 8F38 30 29 00
 16++ 8F3B
# file closed: TestCase004.asm
  5+  8F3B                              INCLUDE "TestCase005.asm"  ; Multiply 8x8 - PERFORMANCE_BALANCED
# file opened: TestCase005.asm
  1++ 8F3B              TestCase005:        ; Test case 5: 16 ร 16 = 256
  2++ 8F3B 3E 10                            LD      A, 16           ; Multiplicand
  3++ 8F3D 06 10                            LD      B, 16           ; Multiplier
  4++ 8F3F 0E 01                            LD      C, PERFORMANCE_BALANCED
  5++ 8F41 CD C2 86                         CALL    Multiply8x8_Unified
  6++ 8F44
  7++ 8F44                                  ; Result should be 256 in HL
  8++ 8F44 11 00 01                         LD      DE, 256         ; Expected result
  9++ 8F47 B7                               OR      A               ; Clear carry
 10++ 8F48 ED 52                            SBC     HL, DE          ; Compare result with expected
 11++ 8F4A 21 53 8F                         LD      HL, MsgTestCase005
 12++ 8F4D C8                               RET     Z               ; Z set is test passed, else test failed.
 13++ 8F4E 3E 05        Test5Failed:        LD      A, 5            ; Test number
 14++ 8F50 C3 AB 8C                         JP      PrintFailedMessage
 15++ 8F53
 16++ 8F53 20 28 31 36  MsgTestCase005:     DB      " (16 x 16 = 256)", 0
 16++ 8F57 20 78 20 31
 16++ 8F5B 36 20 3D 20
 16++ 8F5F 32 35 36 29
 16++ 8F63 00
 17++ 8F64
# file closed: TestCase005.asm
  6+  8F64                              INCLUDE "TestCase006.asm"  ; Divide 8x8 - PERFORMANCE_BALANCED
# file opened: TestCase006.asm
  1++ 8F64              TestCase006:        ; Test case 6: 45 รท 7 = 6 remainder 3
  2++ 8F64 3E 2D                            LD      A, 45           ; Dividend
  3++ 8F66 06 07                            LD      B, 7            ; Divisor
  4++ 8F68 0E 01                            LD      C, PERFORMANCE_BALANCED
  5++ 8F6A CD A2 85                         CALL    Divide8x8_Unified
  6++ 8F6D
  7++ 8F6D                                  ; Result should be A=6, B=3
  8++ 8F6D 21 7D 8F                         LD      HL, MsgTestCase006
  9++ 8F70 FE 06                            CP      6               ; Check quotient
 10++ 8F72 20 04                            JR      NZ, Test6Failed
 11++ 8F74 78                               LD      A, B            ; Get remainder
 12++ 8F75 FE 03                            CP      3               ; Check remainder
 13++ 8F77 C8                               RET     Z               ; Z set is test passed, else test failed.
 14++ 8F78 3E 06        Test6Failed:        LD      A, 6            ; test number
 15++ 8F7A C3 AB 8C                         JP      PrintFailedMessage
 16++ 8F7D
 17++ 8F7D 20 28 34 35  MsgTestCase006:     DB      " (45 / 7 = 6r3)", 0
 17++ 8F81 20 2F 20 37
 17++ 8F85 20 3D 20 36
 17++ 8F89 72 33 29 00
 18++ 8F8D
# file closed: TestCase006.asm
  7+  8F8D                              INCLUDE "TestCase007.asm"  ; Divide 8x8 - PERFORMANCE_BALANCED
# file opened: TestCase007.asm
  1++ 8F8D              TestCase007:        ; Test case 7: 100 รท 8 = 12 remainder 4
  2++ 8F8D 3E 64                            LD      A, 100          ; Dividend
  3++ 8F8F 06 08                            LD      B, 8            ; Divisor
  4++ 8F91 0E 02                            LD      C, PERFORMANCE_MAXIMUM
  5++ 8F93 CD A2 85                         CALL    Divide8x8_Unified
  6++ 8F96
  7++ 8F96                                  ; Result should be A=12, B=4
  8++ 8F96 21 A6 8F                         LD      HL, MsgTestCase007
  9++ 8F99 FE 0C                            CP      12              ; Check quotient
 10++ 8F9B 20 04                            JR      NZ, Test7Failed
 11++ 8F9D 78                               LD      A, B            ; Get remainder
 12++ 8F9E FE 04                            CP      4               ; Check remainder
 13++ 8FA0 C8                               RET     Z               ; Z set is test passed, else test failed.
 14++ 8FA1 3E 07        Test7Failed:        LD      A, 7            ; test number
 15++ 8FA3 C3 AB 8C                         JP      PrintFailedMessage
 16++ 8FA6
 17++ 8FA6 20 28 31 30  MsgTestCase007:     DB      " (100 / 8 = 12r4)", 0
 17++ 8FAA 30 20 2F 20
 17++ 8FAE 38 20 3D 20
 17++ 8FB2 31 32 72 34
 17++ 8FB6 29 00
 18++ 8FB8
# file closed: TestCase007.asm
  8+  8FB8                              INCLUDE "TestCase008.asm"  ; Divide 8x8 - PERFORMANCE_BALANCED
# file opened: TestCase008.asm
  1++ 8FB8              TestCase008:        ; Test case 8: 255 รท 15 = 17 remainder 0
  2++ 8FB8 3E FF                            LD      A, 255          ; Dividend
  3++ 8FBA 06 0F                            LD      B, 15           ; Divisor
  4++ 8FBC 0E 01                            LD      C, PERFORMANCE_BALANCED
  5++ 8FBE CD A2 85                         CALL    Divide8x8_Unified
  6++ 8FC1
  7++ 8FC1                                  ; Result should be A=17, B=0
  8++ 8FC1 21 D1 8F                         LD      HL, MsgTestCase008
  9++ 8FC4 FE 11                            CP      17              ; Check quotient
 10++ 8FC6 20 04                            JR      NZ, Test8Failed
 11++ 8FC8 78                               LD      A, B            ; Get remainder
 12++ 8FC9 FE 00                            CP      0               ; Check remainder
 13++ 8FCB C8                               RET     Z               ; Z set is test passed, else test failed.
 14++ 8FCC 3E 08        Test8Failed:        LD      A, 8
 15++ 8FCE C3 AB 8C                         JP      PrintFailedMessage
 16++ 8FD1
 17++ 8FD1 20 28 32 35  MsgTestCase008:     DB      " (255 / 15 = 17r0)", 0
 17++ 8FD5 35 20 2F 20
 17++ 8FD9 31 35 20 3D
 17++ 8FDD 20 31 37 72
 17++ 8FE1 30 29 00
 18++ 8FE4
# file closed: TestCase008.asm
  9+  8FE4                              INCLUDE "TestCase009.asm"  ; Divide 8x8 - PERFORMANCE_BALANCED
# file opened: TestCase009.asm
  1++ 8FE4              TestCase009:        ; Test case 9: 50 รท 200 = 0 remainder 50 (dividend < divisor)
  2++ 8FE4 3E 32                            LD      A, 50           ; Dividend
  3++ 8FE6 06 C8                            LD      B, 200          ; Divisor
  4++ 8FE8 0E 02                            LD      C, PERFORMANCE_MAXIMUM
  5++ 8FEA CD A2 85                         CALL    Divide8x8_Unified
  6++ 8FED
  7++ 8FED                                  ; Result should be A=0, B=50
  8++ 8FED 21 FD 8F                         LD      HL, MsgTestCase009
  9++ 8FF0 FE 00                            CP      0               ; Check quotient
 10++ 8FF2 20 04                            JR      NZ, Test9Failed
 11++ 8FF4 78                               LD      A, B            ; Get remainder
 12++ 8FF5 FE 32                            CP      50              ; Check remainder
 13++ 8FF7 C8                               RET     Z               ; Z set is test passed, else test failed.
 14++ 8FF8 3E 09        Test9Failed:        LD      A, 9
 15++ 8FFA C3 AB 8C                         JP      PrintFailedMessage
 16++ 8FFD
 17++ 8FFD 20 28 35 30  MsgTestCase009:     DB      " (50 / 200 = 0r50)", 0
 17++ 9001 20 2F 20 32
 17++ 9005 30 30 20 3D
 17++ 9009 20 30 72 35
 17++ 900D 30 29 00
 18++ 9010
# file closed: TestCase009.asm
 10+  9010                              INCLUDE "TestCase010.asm"  ; Divide 16x8 - PERFORMANCE_BALANCED
# file opened: TestCase010.asm
  1++ 9010              TestCase010:        ; Test case 10: 5000 รท 13 = 384 remainder 8 (16-bit division)
  2++ 9010 21 88 13                         LD      HL, 5000        ; Dividend (16-bit)
  3++ 9013 06 0D                            LD      B, 13           ; Divisor
  4++ 9015 0E 01                            LD      C, PERFORMANCE_BALANCED
  5++ 9017 CD 1A 86                         CALL    Divide16x8_Unified
  6++ 901A
  7++ 901A                                  ; Result should be HL=384, A=8
  8++ 901A F5                               PUSH    AF              ; Save remainder
  9++ 901B 11 80 01                         LD      DE, 384         ; Expected quotient
 10++ 901E B7                               OR      A               ; Clear carry
 11++ 901F ED 52                            SBC     HL, DE          ; Compare quotient
 12++ 9021 21 31 90                         LD      HL, MsgTestCase010
 13++ 9024 20 05                            JR      NZ, Test10Failed
 14++ 9026 F1                               POP     AF              ; Restore remainder
 15++ 9027 FE 08                            CP      8               ; Check remainder
 16++ 9029 C8                               RET     Z               ; Z set is test passed, else test failed.
 17++ 902A F5                               PUSH    AF              ; Balance the stack for drop thru
 18++ 902B F1           Test10Failed:       POP     AF              ; Clean up stack
 19++ 902C 3E 0A                            LD      A, 10
 20++ 902E C3 AB 8C                         JP      PrintFailedMessage
 21++ 9031
 22++ 9031 20 28 35 30  MsgTestCase010:     DB      " (5000 / 13 = 384r8)", 0
 22++ 9035 30 30 20 2F
 22++ 9039 20 31 33 20
 22++ 903D 3D 20 33 38
 22++ 9041 34 72 38 29
 22++ 9045 00
 23++ 9046
# file closed: TestCase010.asm
 11+  9046                              INCLUDE "TestCase011.asm"  ; Multiply 16x8 - PERFORMANCE_BALANCED
# file opened: TestCase011.asm
  1++ 9046              TestCase011:        ; Test case 11: 1000 ร 50 = 50000 (16x8 multiplication)
  2++ 9046 21 E8 03                         LD      HL, 1000        ; 16-bit multiplicand
  3++ 9049 06 32                            LD      B, 50           ; 8-bit multiplier
  4++ 904B 0E 01                            LD      C, PERFORMANCE_BALANCED ; Set performance level
  5++ 904D CD 2E 87                         CALL    Multiply16x8_Unified
  6++ 9050
  7++ 9050                                  ; Result should be 50000 = 0xC350 in DE:HL
  8++ 9050                                  ; Since 50000 fits in 16 bits, DE should be 0 and HL should be 50000
  9++ 9050 7A                               LD      A, D
 10++ 9051 B3                               OR      E               ; Check if high word is zero
 11++ 9052 20 0C                            JR      NZ, Test11Failed ; Should be zero for this test case
 12++ 9054
 13++ 9054                                  ; Check if HL = 50000 (0xC350)
 14++ 9054 D5                               PUSH    DE              ; Save high result
 15++ 9055 11 50 C3                         LD      DE, 50000       ; Expected low result
 16++ 9058 B7                               OR      A               ; Clear carry
 17++ 9059 ED 52                            SBC     HL, DE          ; Compare
 18++ 905B D1                               POP     DE              ; Restore high result
 19++ 905C 21 68 90                         LD      HL, MsgTestCase011
 20++ 905F C8                               RET     Z               ; Z set is test passed, else test failed.
 21++ 9060 21 68 90     Test11Failed:       LD      HL, MsgTestCase011
 22++ 9063 3E 0B                            LD      A, 11
 23++ 9065 C3 AB 8C                         JP      PrintFailedMessage
 24++ 9068
 25++ 9068 20 28 31 30  MsgTestCase011:     DB      " (1000 x 50 = 50000)", 0
 25++ 906C 30 30 20 78
 25++ 9070 20 35 30 20
 25++ 9074 3D 20 35 30
 25++ 9078 30 30 30 29
 25++ 907C 00
 26++ 907D
# file closed: TestCase011.asm
 12+  907D                              INCLUDE "TestCase012.asm"  ; Multiply 16x8 - PERFORMANCE_MAXIMUM
# file opened: TestCase012.asm
  1++ 907D              TestCase012:        ; Test case 12: 200 ร 25 = 5000 (16x8 fast multiplication)
  2++ 907D 21 C8 00                         LD      HL, 200         ; 16-bit multiplicand
  3++ 9080 06 19                            LD      B, 25           ; 8-bit multiplier
  4++ 9082 0E 02                            LD      C, PERFORMANCE_MAXIMUM
  5++ 9084 CD 2E 87                         CALL    Multiply16x8_Unified
  6++ 9087
  7++ 9087                                  ; Result should be 5000 = 0x1388 in DE:HL
  8++ 9087                                  ; Since 5000 fits in 16 bits, DE should be 0 and HL should be 5000
  9++ 9087 7A                               LD      A, D
 10++ 9088 B3                               OR      E               ; Check if high word is zero
 11++ 9089 20 0C                            JR      NZ, Test12Failed ; Should be zero for this test case
 12++ 908B
 13++ 908B                                  ; Check if HL = 5000 (0x1388)
 14++ 908B D5                               PUSH    DE              ; Save high result
 15++ 908C 11 88 13                         LD      DE, 5000        ; Expected low result
 16++ 908F B7                               OR      A               ; Clear carry
 17++ 9090 ED 52                            SBC     HL, DE          ; Compare
 18++ 9092 D1                               POP     DE              ; Restore high result
 19++ 9093 21 9F 90                         LD      HL, MsgTestCase012
 20++ 9096 C8                               RET     Z               ; Z set is test passed, else test failed.
 21++ 9097 21 9F 90     Test12Failed:       LD      HL, MsgTestCase012
 22++ 909A 3E 0C                            LD      A, 12
 23++ 909C C3 AB 8C                         JP      PrintFailedMessage
 24++ 909F
 25++ 909F 20 28 32 30  MsgTestCase012:     DB      " (200 x 25 = 5000)", 0
 25++ 90A3 30 20 78 20
 25++ 90A7 32 35 20 3D
 25++ 90AB 20 35 30 30
 25++ 90AF 30 29 00
 26++ 90B2
# file closed: TestCase012.asm
 13+  90B2                              INCLUDE "TestCase013.asm"  ; Divide 16x8 - PERFORMANCE_MAXIMUM
# file opened: TestCase013.asm
  1++ 90B2              TestCase013:        ; Test case 13: 5000 รท 25 = 200 remainder 0 (16x8 fast division)
  2++ 90B2 21 88 13                         LD      HL, 5000        ; 16-bit dividend
  3++ 90B5 06 19                            LD      B, 25           ; 8-bit divisor
  4++ 90B7 0E 02                            LD      C, PERFORMANCE_MAXIMUM
  5++ 90B9 CD 1A 86                         CALL    Divide16x8_Unified
  6++ 90BC
  7++ 90BC                                  ; Result should be quotient=200 in HL, remainder=0 in A
  8++ 90BC F5                               PUSH    AF              ; Save remainder
  9++ 90BD 11 C8 00                         LD      DE, 200         ; Expected quotient
 10++ 90C0 B7                               OR      A               ; Clear carry
 11++ 90C1 ED 52                            SBC     HL, DE          ; Compare quotient
 12++ 90C3 20 07                            JR      NZ, Test13Failed ; Quotient mismatch
 13++ 90C5 F1                               POP     AF              ; Get remainder
 14++ 90C6 B7                               OR      A               ; Check if remainder is 0
 15++ 90C7 21 D5 90                         LD      HL, MsgTestCase013
 16++ 90CA C8                               RET     Z               ; Z set is test passed, else test failed.
 17++ 90CB F5                               PUSH    AF
 18++ 90CC F1           Test13Failed:       POP     AF
 19++ 90CD 21 D5 90                         LD      HL, MsgTestCase013
 20++ 90D0 3E 0D                            LD      A, 13
 21++ 90D2 C3 AB 8C                         JP      PrintFailedMessage
 22++ 90D5
 23++ 90D5 20 28 35 30  MsgTestCase013:      DB      " (5000 / 25 = 200r0)", 0
 23++ 90D9 30 30 20 2F
 23++ 90DD 20 32 35 20
 23++ 90E1 3D 20 32 30
 23++ 90E5 30 72 30 29
 23++ 90E9 00
 24++ 90EA
# file closed: TestCase013.asm
 14+  90EA                              INCLUDE "TestCase014.asm"  ; Random 8-bit LCG
# file opened: TestCase014.asm
  1++ 90EA              TestCase014:        ; Test case 14: Random number generator validation LCG
  2++ 90EA                                  ; Test that random numbers are within specified range (inclusive)
  3++ 90EA 3E 07                            LD      A, 7            ; Upper limit (inclusive)
  4++ 90EC 06 2A                            LD      B, 42           ; Set seed to 42
  5++ 90EE 0E 00                            LD      C, PERFORMANCE_RANDOM_LCG
  6++ 90F0
  7++ 90F0 CD F4 87                         CALL    Random8_Unified_Seed
  8++ 90F3                                  ; A now contains first random number in range 0-7
  9++ 90F3 FE 08                            CP      8               ; Check if < 8
 10++ 90F5 30 22                            JR      NC, Test14Failed ; If >= 8, test failed
 11++ 90F7
 12++ 90F7                                  ; Test range 0-9 (limit = 9, inclusive)
 13++ 90F7 3E 09                            LD      A, 9            ; Upper limit (inclusive)
 14++ 90F9 0E 00                            LD      C, PERFORMANCE_RANDOM_LCG
 15++ 90FB
 16++ 90FB CD 2C 88                         CALL    Random8_Unified_Next
 17++ 90FE FE 0A                            CP      10              ; Check if < 10
 18++ 9100 30 17                            JR      NC, Test14Failed ; If >= 10, test failed
 19++ 9102
 20++ 9102                                  ; Test edge case: limit = 1 (should return 0 or 1)
 21++ 9102 3E 01                            LD      A, 1            ; Upper limit (inclusive)
 22++ 9104 0E 00                            LD      C, PERFORMANCE_RANDOM_LCG
 23++ 9106
 24++ 9106 CD 2C 88                         CALL    Random8_Unified_Next
 25++ 9109 FE 02                            CP      2               ; Check if < 2
 26++ 910B 30 0C                            JR      NC, Test14Failed ; If >= 2, test failed
 27++ 910D
 28++ 910D                                  ; Test edge case: limit = 0 (should return 0)
 29++ 910D 3E 00                            LD      A, 0            ; Upper limit (inclusive)
 30++ 910F 0E 00                            LD      C, PERFORMANCE_RANDOM_LCG
 31++ 9111
 32++ 9111 CD 2C 88                         CALL    Random8_Unified_Next
 33++ 9114 B7                               OR      A               ; Check if 0
 34++ 9115 21 21 91                         LD      HL, MsgTestCase014
 35++ 9118 C8                               RET     Z               ; Z set is test passed, else test failed.
 36++ 9119 21 21 91     Test14Failed:       LD      HL, MsgTestCase014
 37++ 911C 3E 0E                            LD      A, 14
 38++ 911E C3 AB 8C                         JP      PrintFailedMessage
 39++ 9121
 40++ 9121 20 52 61 6E  MsgTestCase014:     DB      " Random LCG", 0
 40++ 9125 64 6F 6D 20
 40++ 9129 4C 43 47 00
 41++ 912D
# file closed: TestCase014.asm
 15+  912D                              INCLUDE "TestCase015.asm"  ; Random 8-bit XOR
# file opened: TestCase015.asm
  1++ 912D              TestCase015:        ; Test case 15: Random number generator validation XORShift
  2++ 912D                                  ; Test that random numbers are within specified range (inclusive)
  3++ 912D 3E 07                            LD      A, 7            ; Upper limit (inclusive)
  4++ 912F 06 2A                            LD      B, 42           ; Set seed to 42
  5++ 9131 0E 02                            LD      C, PERFORMANCE_RANDOM_XORSHIFT
  6++ 9133
  7++ 9133 CD F4 87                         CALL    Random8_Unified_Seed
  8++ 9136                                  ; A now contains first random number in range 0-7
  9++ 9136 FE 08                            CP      8               ; Check if < 8
 10++ 9138 30 22                            JR      NC, Test15Failed ; If >= 8, test failed
 11++ 913A
 12++ 913A                                  ; Test range 0-9 (limit = 9, inclusive)
 13++ 913A 3E 09                            LD      A, 9            ; Upper limit (inclusive)
 14++ 913C 0E 02                            LD      C, PERFORMANCE_RANDOM_XORSHIFT
 15++ 913E
 16++ 913E CD 2C 88                         CALL    Random8_Unified_Next
 17++ 9141 FE 0A                            CP      10              ; Check if < 10
 18++ 9143 30 17                            JR      NC, Test15Failed ; If >= 10, test failed
 19++ 9145
 20++ 9145                                  ; Test edge case: limit = 1 (should return 0 or 1)
 21++ 9145 3E 01                            LD      A, 1            ; Upper limit (inclusive)
 22++ 9147 0E 02                            LD      C, PERFORMANCE_RANDOM_XORSHIFT
 23++ 9149
 24++ 9149 CD 2C 88                         CALL    Random8_Unified_Next
 25++ 914C FE 02                            CP      2               ; Check if < 2
 26++ 914E 30 0C                            JR      NC, Test15Failed ; If >= 2, test failed
 27++ 9150
 28++ 9150                                  ; Test edge case: limit = 0 (should return 0)
 29++ 9150 3E 00                            LD      A, 0            ; Upper limit (inclusive)
 30++ 9152 0E 02                            LD      C, PERFORMANCE_RANDOM_XORSHIFT
 31++ 9154
 32++ 9154 CD 2C 88                         CALL    Random8_Unified_Next
 33++ 9157 B7                               OR      A               ; Check if 0
 34++ 9158 21 64 91                         LD      HL, MsgTestCase015
 35++ 915B C8                               RET     Z               ; Z set is test passed, else test failed.
 36++ 915C 21 64 91     Test15Failed:       LD      HL, MsgTestCase015
 37++ 915F 3E 0F                            LD      A, 15
 38++ 9161 C3 AB 8C                         JP      PrintFailedMessage
 39++ 9164
 40++ 9164 20 52 61 6E  MsgTestCase015:     DB      " Random XOR", 0
 40++ 9168 64 6F 6D 20
 40++ 916C 58 4F 52 00
 41++ 9170
# file closed: TestCase015.asm
 16+  9170                              INCLUDE "TestCase016.asm"  ; Random 8-bit LFSR
# file opened: TestCase016.asm
  1++ 9170              TestCase016:        ; Test case 16: LFSR random number generator
  2++ 9170 3E 0F                            LD      A, 15           ; Upper limit (inclusive)
  3++ 9172 06 7B                            LD      B, 123          ; Set seed to 123
  4++ 9174 0E 01                            LD      C, PERFORMANCE_RANDOM_LFSR
  5++ 9176
  6++ 9176 CD F4 87                         CALL    Random8_Unified_Seed
  7++ 9179                                  ; A now contains first random number in range 0-15
  8++ 9179 FE 10                            CP      16              ; Check if <= 15
  9++ 917B 30 0F                            JR      NC, Test16Failed ; If >= 16, test failed
 10++ 917D
 11++ 917D                                  ; Test multiple calls to ensure generator advances
 12++ 917D 3E 1F                            LD      A, 31           ; Upper limit (inclusive)
 13++ 917F 0E 01                            LD      C, PERFORMANCE_RANDOM_LFSR
 14++ 9181
 15++ 9181 CD 2C 88                         CALL    Random8_Unified_Next
 16++ 9184 FE 20                            CP      32              ; Check if < 32 (0 - 31)
 17++ 9186 21 94 91                         LD      HL, MsgTestCase016
 18++ 9189 DA 3B 8D                         JP      C, SetTestPassing ; Pass if < 32.
 19++ 918C
 20++ 918C 21 94 91     Test16Failed:       LD      HL, MsgTestCase016
 21++ 918F 3E 10                            LD      A, 16
 22++ 9191 C3 AB 8C                         JP      PrintFailedMessage
 23++ 9194
 24++ 9194 20 52 61 6E  MsgTestCase016:     DB      " Random LFSR", 0
 24++ 9198 64 6F 6D 20
 24++ 919C 4C 46 53 52
 24++ 91A0 00
 25++ 91A1
# file closed: TestCase016.asm
 17+  91A1                              INCLUDE "TestCase017.asm"  ; Random 8-bit Middle Square
# file opened: TestCase017.asm
  1++ 91A1              TestCase017:             ; Test case 17: Middle Square random number generator
  2++ 91A1 3E 03                            LD      A, 3            ; Upper limit (inclusive)
  3++ 91A3 06 39                            LD      B, 57           ; Set seed to 57
  4++ 91A5 0E 03                            LD      C, PERFORMANCE_RANDOM_MIDDLESQUARE
  5++ 91A7
  6++ 91A7 CD F4 87                         CALL    Random8_Unified_Seed
  7++ 91AA                                  ; A now contains first random number in range 0-3
  8++ 91AA FE 04                            CP      4               ; Check if <= 3
  9++ 91AC 30 0F                            JR      NC, Test17Failed ; If >= 4, test failed
 10++ 91AE
 11++ 91AE                                  ; Test range 0-10 (limit = 10, inclusive)
 12++ 91AE 3E 0A                            LD      A, 10           ; Upper limit (inclusive)
 13++ 91B0 0E 03                            LD      C, PERFORMANCE_RANDOM_MIDDLESQUARE
 14++ 91B2
 15++ 91B2 CD 2C 88                         CALL    Random8_Unified_Next
 16++ 91B5 FE 0B                            CP      11              ; Check if <= 10
 17++ 91B7 21 C5 91                         LD      HL, MsgTestCase017
 18++ 91BA DA 3B 8D                         JP      C, SetTestPassing ; if < 11, test passed.
 19++ 91BD 21 C5 91     Test17Failed:       LD      HL, MsgTestCase017
 20++ 91C0 3E 11                            LD      A, 17
 21++ 91C2 C3 AB 8C                         JP      PrintFailedMessage
 22++ 91C5
 23++ 91C5 20 52 61 6E  MsgTestCase017:     DB      " Random Mid Square", 0
 23++ 91C9 64 6F 6D 20
 23++ 91CD 4D 69 64 20
 23++ 91D1 53 71 75 61
 23++ 91D5 72 65 00
# file closed: TestCase017.asm
 18+  91D8                              INCLUDE "TestCase018.asm"  ; Random 16-bit LCG
# file opened: TestCase018.asm
  1++ 91D8              TestCase018:        ; Test case 18: 16-bit LCG random number generator
  2++ 91D8 21 E7 03                         LD      HL, 999         ; Upper limit (inclusive)
  3++ 91DB 01 39 30                         LD      BC, 12345       ; Set seed to 12345
  4++ 91DE 16 00                            LD      D, PERFORMANCE_RANDOM_LCG
  5++ 91E0 CD 41 89                         CALL    Random16_Unified_Seed
  6++ 91E3
  7++ 91E3                                  ; HL now contains first random number in range 0-999
  8++ 91E3 11 E8 03                         LD      DE, 1000        ; Check if <= 999 (same as < 1000)
  9++ 91E6 B7                               OR      A               ; Clear carry
 10++ 91E7 ED 52                            SBC     HL, DE          ; Compare HL with 1000
 11++ 91E9 19                               ADD     HL, DE          ; Restore HL
 12++ 91EA 30 1F                            JR      NC, Test18Failed ; If >= 1000, test failed
 13++ 91EC
 14++ 91EC                                  ; Test range 0-49 (limit = 49, inclusive)
 15++ 91EC 21 31 00                         LD      HL, 49          ; Upper limit (inclusive)
 16++ 91EF 16 00                            LD      D, PERFORMANCE_RANDOM_LCG
 17++ 91F1 CD 81 89                         CALL    Random16_Unified_Next
 18++ 91F4 11 32 00                         LD      DE, 50          ; Check if <= 49 (same as < 50)
 19++ 91F7 B7                               OR      A               ; Clear carry
 20++ 91F8 ED 52                            SBC     HL, DE          ; Compare HL with 50
 21++ 91FA 19                               ADD     HL, DE          ; Restore HL
 22++ 91FB 30 0E                            JR      NC, Test18Failed ; If >= 50, test failed
 23++ 91FD
 24++ 91FD                                  ; Test edge case: limit = 0 (should return 0)
 25++ 91FD 21 00 00                         LD      HL, 0           ; Upper limit (inclusive)
 26++ 9200 16 00                            LD      D, PERFORMANCE_RANDOM_LCG
 27++ 9202 CD 81 89                         CALL    Random16_Unified_Next
 28++ 9205 7C                               LD      A, H            ; Check if HL is 0
 29++ 9206 B5                               OR      L
 30++ 9207 21 13 92                         LD      HL, MsgTestCase018
 31++ 920A C8                               RET     Z               ; Z set is test passed, else test failed.
 32++ 920B 21 13 92     Test18Failed:       LD      HL, MsgTestCase018
 33++ 920E 3E 12                            LD      A, 18
 34++ 9210 C3 AB 8C                         JP      PrintFailedMessage
 35++ 9213
 36++ 9213 20 52 61 6E  MsgTestCase018:     DB      " Random16 LCG", 0
 36++ 9217 64 6F 6D 31
 36++ 921B 36 20 4C 43
 36++ 921F 47 00
 37++ 9221
# file closed: TestCase018.asm
 19+  9221                              INCLUDE "TestCase019.asm"  ; Random 16-bit XOR
# file opened: TestCase019.asm
  1++ 9221              TestCase019:        ; Test case 19: 16-bit XORShift random number generator
  2++ 9221 21 7F 00                         LD      HL, 127         ; Upper limit (inclusive)
  3++ 9224 01 31 D4                         LD      BC, 54321       ; Set seed to 54321
  4++ 9227 16 02                            LD      D, PERFORMANCE_RANDOM_XORSHIFT
  5++ 9229 CD 41 89                         CALL    Random16_Unified_Seed
  6++ 922C
  7++ 922C                                  ; HL now contains first random number in range 0-127
  8++ 922C 11 80 00                         LD      DE, 128         ; Check if <= 127 (same as < 128)
  9++ 922F B7                               OR      A               ; Clear carry
 10++ 9230 ED 52                            SBC     HL, DE          ; Compare HL with 128
 11++ 9232 19                               ADD     HL, DE          ; Restore HL
 12++ 9233 30 14                            JR      NC, Test19Failed ; If >= 128, test failed
 13++ 9235
 14++ 9235                                  ; Test range 0-255 (limit = 255, inclusive)
 15++ 9235 21 FF 00                         LD      HL, 255         ; Upper limit (inclusive)
 16++ 9238 16 02                            LD      D, PERFORMANCE_RANDOM_XORSHIFT
 17++ 923A CD 81 89                         CALL    Random16_Unified_Next
 18++ 923D
 19++ 923D                                  ; HL now contains first random number in range 0-255
 20++ 923D 11 00 01                         LD      DE, 256         ; Check if <= 255 (same as < 256)
 21++ 9240 B7                               OR      A               ; Clear carry
 22++ 9241 ED 52                            SBC     HL, DE          ; Compare HL with 256
 23++ 9243 21 51 92                         LD      HL, MsgTestCase019
 24++ 9246 DA 3B 8D                         JP      C, SetTestPassing ; If carry set, test passed
 25++ 9249 21 51 92     Test19Failed:       LD      HL, MsgTestCase019
 26++ 924C 3E 13                            LD      A, 19
 27++ 924E C3 AB 8C                         JP      PrintFailedMessage
 28++ 9251
 29++ 9251 20 52 61 6E  MsgTestCase019:     DB      " Random16 XOR", 0
 29++ 9255 64 6F 6D 31
 29++ 9259 36 20 58 4F
 29++ 925D 52 00
 30++ 925F
# file closed: TestCase019.asm
 20+  925F                              INCLUDE "TestCase020.asm"  ; Random 16-bit LFSR
# file opened: TestCase020.asm
  1++ 925F              TestCase020:        ; Test case 20: 16-bit LFSR random number generator
  2++ 925F 21 FF 01                         LD      HL, 511         ; Upper limit (inclusive)
  3++ 9262 01 94 26                         LD      BC, 9876        ; Set seed to 9876
  4++ 9265 16 01                            LD      D, PERFORMANCE_RANDOM_LFSR
  5++ 9267 CD 41 89                         CALL    Random16_Unified_Seed
  6++ 926A
  7++ 926A                                  ; HL now contains first random number in range 0-511
  8++ 926A 11 00 02                         LD      DE, 512         ; Check if <= 511 (same as < 512)
  9++ 926D B7                               OR      A               ; Clear carry
 10++ 926E ED 52                            SBC     HL, DE          ; Compare HL with 512
 11++ 9270 19                               ADD     HL, DE          ; Restore HL
 12++ 9271 30 14                            JR      NC, Test20Failed ; If >= 512, test failed
 13++ 9273
 14++ 9273                                  ; Test multiple calls to ensure generator advances
 15++ 9273 21 FF 03                         LD      HL, 1023        ; Upper limit (inclusive)
 16++ 9276 16 01                            LD      D, PERFORMANCE_RANDOM_LFSR
 17++ 9278 CD 81 89                         CALL    Random16_Unified_Next
 18++ 927B 11 00 04                         LD      DE, 1024        ; Check if <= 1023 (same as < 1024)
 19++ 927E B7                               OR      A               ; Clear carry
 20++ 927F ED 52                            SBC     HL, DE          ; Compare HL with 1024
 21++ 9281 21 8F 92                         LD      HL, MsgTestCase020
 22++ 9284 DA 3B 8D                         JP      C, SetTestPassing ; If carry set, test passed
 23++ 9287 21 8F 92     Test20Failed:       LD      HL, MsgTestCase020
 24++ 928A 3E 14                            LD      A, 20
 25++ 928C C3 AB 8C                         JP      PrintFailedMessage
 26++ 928F
 27++ 928F 20 52 61 6E  MsgTestCase020:     DB      " Random16 LFSR", 0
 27++ 9293 64 6F 6D 31
 27++ 9297 36 20 4C 46
 27++ 929B 53 52 00
 28++ 929E
# file closed: TestCase020.asm
 21+  929E                              INCLUDE "TestCase021.asm"  ; Random 16-bit Middle Square
# file opened: TestCase021.asm
  1++ 929E              TestCase021:        ; Test case 21: 16-bit Middle Square random number generator
  2++ 929E 21 3F 00                         LD      HL, 63          ; Upper limit (inclusive)
  3++ 92A1 01 D7 11                         LD      BC, 4567        ; Set seed to 4567
  4++ 92A4 16 03                            LD      D, PERFORMANCE_RANDOM_MIDDLESQUARE
  5++ 92A6 CD 41 89                         CALL    Random16_Unified_Seed
  6++ 92A9
  7++ 92A9                                  ; HL now contains first random number in range 0-63
  8++ 92A9 11 40 00                         LD      DE, 64          ; Check if <= 63 (same as < 64)
  9++ 92AC B7                               OR      A               ; Clear carry
 10++ 92AD ED 52                            SBC     HL, DE          ; Compare HL with 64
 11++ 92AF 19                               ADD     HL, DE          ; Restore HL
 12++ 92B0 30 14                            JR      NC, Test21Failed ; If >= 64, test failed
 13++ 92B2
 14++ 92B2                                  ; Test range 0-31 (limit = 31, inclusive)
 15++ 92B2 21 1F 00                         LD      HL, 31          ; Upper limit (inclusive)
 16++ 92B5 16 03                            LD      D, PERFORMANCE_RANDOM_MIDDLESQUARE
 17++ 92B7 CD 81 89                         CALL    Random16_Unified_Next
 18++ 92BA
 19++ 92BA 11 20 00                         LD      DE, 32          ; Check if <= 31 (same as < 32)
 20++ 92BD B7                               OR      A               ; Clear carry
 21++ 92BE ED 52                            SBC     HL, DE          ; Compare HL with 32
 22++ 92C0 21 CE 92                         LD      HL, MsgTestCase021
 23++ 92C3 DA 3B 8D                         JP      C, SetTestPassing ; If carry set, test passed
 24++ 92C6 21 CE 92     Test21Failed:       LD      HL, MsgTestCase021
 25++ 92C9 3E 15                            LD      A, 21
 26++ 92CB C3 AB 8C                         JP      PrintFailedMessage
 27++ 92CE
 28++ 92CE 20 52 61 6E  MsgTestCase021:     DB      " Random16 Mid Square", 0
 28++ 92D2 64 6F 6D 31
 28++ 92D6 36 20 4D 69
 28++ 92DA 64 20 53 71
 28++ 92DE 75 61 72 65
 28++ 92E2 00
 29++ 92E3
# file closed: TestCase021.asm
 22+  92E3                              INCLUDE "TestCase022.asm"  ; Convert 0 without leading zeros
# file opened: TestCase022.asm
  1++ 92E3              TestCase022:        ; Test 22 - Convert 0 without leading zeros, should produce "0"
  2++ 92E3 21 00 00                         LD      HL, 0           ; Value to convert
  3++ 92E6 3E 01                            LD      A, 1            ; No leading zeros
  4++ 92E8 11 11 8D                         LD      DE, ConversionBuffer
  5++ 92EB CD 58 8B                         CALL    ConvertToDecimal
  6++ 92EE              ;
  7++ 92EE              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  8++ 92EE              ;
  9++ 92EE                                  ; Check length should be 1
 10++ 92EE FE 01                            CP      1
 11++ 92F0 20 10                            JR      NZ, Test22Failed
 12++ 92F2
 13++ 92F2                                  ; Check result should be "0", 0
 14++ 92F2 21 11 8D                         LD      HL, ConversionBuffer
 15++ 92F5 7E                               LD      A, (HL)
 16++ 92F6 FE 30                            CP      '0'
 17++ 92F8 20 08                            JR      NZ, Test22Failed
 18++ 92FA 23                               INC     HL
 19++ 92FB 7E                               LD      A, (HL)
 20++ 92FC FE 00                            CP      0               ; Null terminator
 21++ 92FE 21 0A 93                         LD      HL, MsgTestCase022
 22++ 9301 C8                               RET     Z               ; Z set is test passed, else test failed.
 23++ 9302 21 0A 93     Test22Failed:       LD      HL, MsgTestCase022
 24++ 9305 3E 16                            LD      A, 22
 25++ 9307 C3 AB 8C                         JP      PrintFailedMessage
 26++ 930A
 27++ 930A 20 43 76 74  MsgTestCase022:     DB " Cvt. 0", 0
 27++ 930E 2E 20 30 00
 28++ 9312
# file closed: TestCase022.asm
 23+  9312                              INCLUDE "TestCase023.asm"  ; Convert 0 with leading zeros
# file opened: TestCase023.asm
  1++ 9312              TestCase023:        ; Test23 - Convert 0 with leading zeros, should produce "00000"
  2++ 9312 21 00 00                         LD      HL, 0           ; Value to convert
  3++ 9315 3E 00                            LD      A, 0            ; With leading zeros
  4++ 9317 11 11 8D                         LD      DE, ConversionBuffer
  5++ 931A CD 58 8B                         CALL    ConvertToDecimal
  6++ 931D              ;
  7++ 931D              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  8++ 931D              ;
  9++ 931D                                  ; Check length should be 5
 10++ 931D FE 05                            CP      5
 11++ 931F 20 14                            JR      NZ, Test23Failed
 12++ 9321
 13++ 9321                                  ; Check result should be "00000"
 14++ 9321 21 11 8D                         LD      HL, ConversionBuffer
 15++ 9324 06 05                            LD      B, 5            ; Check 5 zeros
 16++ 9326 7E           Test23CheckLoop:    LD      A, (HL)
 17++ 9327 FE 30                            CP      '0'
 18++ 9329 20 0A                            JR      NZ, Test23Failed
 19++ 932B 23                               INC     HL
 20++ 932C 10 F8                            DJNZ    Test23CheckLoop
 21++ 932E 7E                               LD      A, (HL)
 22++ 932F FE 00                            CP      0               ; Null terminator
 23++ 9331 21 3D 93                         LD      HL, MsgTestCase023
 24++ 9334 C8                               RET     Z               ; Z set is test passed, else test failed.
 25++ 9335 21 3D 93     Test23Failed:       LD      HL, MsgTestCase023
 26++ 9338 3E 17                            LD      A, 23
 27++ 933A C3 AB 8C                         JP      PrintFailedMessage
 28++ 933D
 29++ 933D 20 43 76 74  MsgTestCase023:     DB " Cvt. 0 with ldg 0", 0
 29++ 9341 2E 20 30 20
 29++ 9345 77 69 74 68
 29++ 9349 20 6C 64 67
 29++ 934D 20 30 00
 30++ 9350
# file closed: TestCase023.asm
 24+  9350                              INCLUDE "TestCase024.asm"  ; Convert 1 without leading zeros
# file opened: TestCase024.asm
  1++ 9350              TestCase024:        ; Test24 - Convert 1 without leading zeros, should produce "1"
  2++ 9350 21 01 00                         LD      HL, 1           ; Value to convert
  3++ 9353 3E 01                            LD      A, 1            ; No leading zeros
  4++ 9355 11 11 8D                         LD      DE, ConversionBuffer
  5++ 9358 CD 58 8B                         CALL    ConvertToDecimal
  6++ 935B              ;
  7++ 935B              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  8++ 935B              ;
  9++ 935B                                  ; Check length should be 1
 10++ 935B FE 01                            CP      1
 11++ 935D 20 10                            JR      NZ, Test24Failed
 12++ 935F
 13++ 935F                                  ; Check result should be "1"
 14++ 935F 21 11 8D                         LD      HL, ConversionBuffer
 15++ 9362 7E                               LD      A, (HL)
 16++ 9363 FE 31                            CP      '1'
 17++ 9365 20 08                            JR      NZ, Test24Failed
 18++ 9367 23                               INC     HL
 19++ 9368 7E                               LD      A, (HL)
 20++ 9369 FE 00                            CP      0               ; Null terminator
 21++ 936B 21 77 93                         LD      HL, MsgTestCase024
 22++ 936E C8                               RET     Z               ; Z set is test passed, else test failed.
 23++ 936F 21 77 93     Test24Failed:       LD      HL, MsgTestCase024
 24++ 9372 3E 18                            LD      A, 24
 25++ 9374 C3 AB 8C                         JP      PrintFailedMessage
 26++ 9377
 27++ 9377 20 43 76 74  MsgTestCase024:     DB " Cvt. 1", 0
 27++ 937B 2E 20 31 00
 28++ 937F
# file closed: TestCase024.asm
 25+  937F                              INCLUDE "TestCase025.asm"  ; Convert 1 with leading zeros
# file opened: TestCase025.asm
  1++ 937F              TestCase025:        ; Test25 - Convert 1 with leading zeros. should produce "00001"
  2++ 937F 21 01 00                         LD      HL, 1           ; Value to convert
  3++ 9382 3E 00                            LD      A, 0            ; With leading zeros
  4++ 9384 11 11 8D                         LD      DE, ConversionBuffer
  5++ 9387 CD 58 8B                         CALL    ConvertToDecimal
  6++ 938A              ;
  7++ 938A              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  8++ 938A              ;
  9++ 938A                                  ; Check length should be 5
 10++ 938A FE 05                            CP      5
 11++ 938C 20 1A                            JR      NZ, Test25Failed
 12++ 938E
 13++ 938E                                  ; Check result should be "00001"
 14++ 938E 21 11 8D                         LD      HL, ConversionBuffer
 15++ 9391 06 04                            LD      B, 4            ; Check first 4 zeros
 16++ 9393 7E           Test25CheckZeros:   LD      A, (HL)
 17++ 9394 FE 30                            CP      '0'
 18++ 9396 20 10                            JR      NZ, Test25Failed
 19++ 9398 23                               INC     HL
 20++ 9399 10 F8                            DJNZ    Test25CheckZeros
 21++ 939B 7E                               LD      A, (HL)         ; Check last digit
 22++ 939C FE 31                            CP      '1'
 23++ 939E 20 08                            JR      NZ, Test25Failed
 24++ 93A0 23                               INC     HL
 25++ 93A1 7E                               LD      A, (HL)
 26++ 93A2 FE 00                            CP      0               ; Null terminator
 27++ 93A4 21 B0 93                         LD      HL, MsgTestCase025
 28++ 93A7 C8                               RET     Z               ; Z set is test passed, else test failed.
 29++ 93A8 21 B0 93     Test25Failed:       LD      HL, MsgTestCase025
 30++ 93AB 3E 19                            LD      A, 25
 31++ 93AD C3 AB 8C                         JP      PrintFailedMessage
 32++ 93B0
 33++ 93B0 20 43 76 74  MsgTestCase025:     DB " Cvt. 1 with ldg 0", 0
 33++ 93B4 2E 20 31 20
 33++ 93B8 77 69 74 68
 33++ 93BC 20 6C 64 67
 33++ 93C0 20 30 00
 34++ 93C3
# file closed: TestCase025.asm
 26+  93C3                              INCLUDE "TestCase026.asm"  ; Convert 123 without leading zeros
# file opened: TestCase026.asm
  1++ 93C3              TestCase026:        ; Test26 - Convert 123 without leading zeros, should produce "123"
  2++ 93C3 21 7B 00                         LD      HL, 123         ; Value to convert
  3++ 93C6 3E 01                            LD      A, 1            ; No leading zeros
  4++ 93C8 11 11 8D                         LD      DE, ConversionBuffer
  5++ 93CB CD 58 8B                         CALL    ConvertToDecimal
  6++ 93CE              ;
  7++ 93CE              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  8++ 93CE              ;
  9++ 93CE                                  ; Check length should be 3
 10++ 93CE FE 03                            CP      3
 11++ 93D0 20 1C                            JR      NZ, Test26Failed
 12++ 93D2
 13++ 93D2                                  ; Check result should be "123"
 14++ 93D2 21 11 8D                         LD      HL, ConversionBuffer
 15++ 93D5 7E                               LD      A, (HL)
 16++ 93D6 FE 31                            CP      '1'
 17++ 93D8 20 14                            JR      NZ, Test26Failed
 18++ 93DA 23                               INC     HL
 19++ 93DB 7E                               LD      A, (HL)
 20++ 93DC FE 32                            CP      '2'
 21++ 93DE 20 0E                            JR      NZ, Test26Failed
 22++ 93E0 23                               INC     HL
 23++ 93E1 7E                               LD      A, (HL)
 24++ 93E2 FE 33                            CP      '3'
 25++ 93E4 20 08                            JR      NZ, Test26Failed
 26++ 93E6 23                               INC     HL
 27++ 93E7 7E                               LD      A, (HL)
 28++ 93E8 FE 00                            CP      0               ; Null terminator
 29++ 93EA 21 F6 93                         LD      HL, MsgTestCase026
 30++ 93ED C8                               RET     Z               ; Z set is test passed, else test failed.
 31++ 93EE 21 F6 93     Test26Failed:       LD      HL, MsgTestCase026
 32++ 93F1 3E 1A                            LD      A, 26
 33++ 93F3 C3 AB 8C                         JP      PrintFailedMessage
 34++ 93F6
 35++ 93F6 20 43 76 74  MsgTestCase026:     DB " Cvt. 123", 0
 35++ 93FA 2E 20 31 32
 35++ 93FE 33 00
 36++ 9400
# file closed: TestCase026.asm
 27+  9400                              INCLUDE "TestCase027.asm"  ; Convert 123 with leading zeros
# file opened: TestCase027.asm
  1++ 9400              TestCase027:        ; Test27 - Convert 123 with leading zeros, should produce "00123"
  2++ 9400 21 7B 00                         LD      HL, 123         ; Value to convert
  3++ 9403 3E 00                            LD      A, 0            ; With leading zeros
  4++ 9405 11 11 8D                         LD      DE, ConversionBuffer
  5++ 9408 CD 58 8B                         CALL    ConvertToDecimal
  6++ 940B              ;
  7++ 940B              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  8++ 940B              ;
  9++ 940B                                  ; Check length should be 5
 10++ 940B FE 05                            CP      5
 11++ 940D 20 28                            JR      NZ, Test27Failed
 12++ 940F
 13++ 940F                                  ; Check result should be "00123"
 14++ 940F 21 11 8D                         LD      HL, ConversionBuffer
 15++ 9412 7E                               LD      A, (HL)
 16++ 9413 FE 30                            CP      '0'
 17++ 9415 20 20                            JR      NZ, Test27Failed
 18++ 9417 23                               INC     HL
 19++ 9418 7E                               LD      A, (HL)
 20++ 9419 FE 30                            CP      '0'
 21++ 941B 20 1A                            JR      NZ, Test27Failed
 22++ 941D 23                               INC     HL
 23++ 941E 7E                               LD      A, (HL)
 24++ 941F FE 31                            CP      '1'
 25++ 9421 20 14                            JR      NZ, Test27Failed
 26++ 9423 23                               INC     HL
 27++ 9424 7E                               LD      A, (HL)
 28++ 9425 FE 32                            CP      '2'
 29++ 9427 20 0E                            JR      NZ, Test27Failed
 30++ 9429 23                               INC     HL
 31++ 942A 7E                               LD      A, (HL)
 32++ 942B FE 33                            CP      '3'
 33++ 942D 20 08                            JR      NZ, Test27Failed
 34++ 942F 23                               INC     HL
 35++ 9430 7E                               LD      A, (HL)
 36++ 9431 FE 00                            CP      0               ; Null terminator
 37++ 9433 21 3F 94                         LD      HL, MsgTestCase027
 38++ 9436 C8                               RET     Z               ; Z set is test passed, else test failed.
 39++ 9437 21 3F 94     Test27Failed:       LD      HL, MsgTestCase027
 40++ 943A 3E 1B                            LD      A, 27
 41++ 943C C3 AB 8C                         JP      PrintFailedMessage
 42++ 943F
 43++ 943F 20 43 76 74  MsgTestCase027:      DB " Cvt. 123 with ldg 0", 0
 43++ 9443 2E 20 31 32
 43++ 9447 33 20 77 69
 43++ 944B 74 68 20 6C
 43++ 944F 64 67 20 30
 43++ 9453 00
 44++ 9454
# file closed: TestCase027.asm
 28+  9454                              INCLUDE "TestCase028.asm"  ; Convert 9999 without leading zeros
# file opened: TestCase028.asm
  1++ 9454              TestCase028:        ; Test28 - Convert 9999 without leading zeros, should produce "9999"
  2++ 9454 21 0F 27                         LD      HL, 9999        ; Value to convert
  3++ 9457 3E 01                            LD      A, 1            ; No leading zeros
  4++ 9459 11 11 8D                         LD      DE, ConversionBuffer
  5++ 945C CD 58 8B                         CALL    ConvertToDecimal
  6++ 945F              ;
  7++ 945F              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  8++ 945F              ;
  9++ 945F                                  ; Check length should be 4
 10++ 945F FE 04                            CP      4
 11++ 9461 20 14                            JR      NZ, Test28Failed
 12++ 9463
 13++ 9463                                  ; Check result should be "9999"
 14++ 9463 21 11 8D                         LD      HL, ConversionBuffer
 15++ 9466 06 04                            LD      B, 4            ; Check 4 nines
 16++ 9468 7E           Test28CheckLoop:    LD      A, (HL)
 17++ 9469 FE 39                            CP      '9'
 18++ 946B 20 0A                            JR      NZ, Test28Failed
 19++ 946D 23                               INC     HL
 20++ 946E 10 F8                            DJNZ    Test28CheckLoop
 21++ 9470 7E                               LD      A, (HL)
 22++ 9471 FE 00                            CP      0               ; Null terminator
 23++ 9473 21 7F 94                         LD      HL, MsgTestCase028
 24++ 9476 C8                               RET     Z               ; Z set is test passed, else test failed.
 25++ 9477 21 7F 94     Test28Failed:       LD      HL, MsgTestCase028
 26++ 947A 3E 1C                            LD      A, 28
 27++ 947C C3 AB 8C                         JP      PrintFailedMessage
 28++ 947F
 29++ 947F 20 43 76 74  MsgTestCase028:     DB " Cvt. 9999", 0
 29++ 9483 2E 20 39 39
 29++ 9487 39 39 00
 30++ 948A
# file closed: TestCase028.asm
 29+  948A                              INCLUDE "TestCase029.asm"  ; Convert 65535 without leading zeros
# file opened: TestCase029.asm
  1++ 948A              TestCase029:        ; Test29 - Convert 65535 without leading zeros, should produce "65535"
  2++ 948A 21 FF FF                         LD      HL, 65535       ; Value to convert (maximum 16-bit)
  3++ 948D 3E 01                            LD      A, 1            ; No leading zeros
  4++ 948F 11 11 8D                         LD      DE, ConversionBuffer
  5++ 9492 CD 58 8B                         CALL    ConvertToDecimal
  6++ 9495              ;
  7++ 9495              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  8++ 9495              ;
  9++ 9495                                  ; Check length should be 5
 10++ 9495 FE 05                            CP      5
 11++ 9497 20 28                            JR      NZ, Test29Failed
 12++ 9499
 13++ 9499                                  ; Check result should be "65535"
 14++ 9499 21 11 8D                         LD      HL, ConversionBuffer
 15++ 949C 7E                               LD      A, (HL)
 16++ 949D FE 36                            CP      '6'
 17++ 949F 20 20                            JR      NZ, Test29Failed
 18++ 94A1 23                               INC     HL
 19++ 94A2 7E                               LD      A, (HL)
 20++ 94A3 FE 35                            CP      '5'
 21++ 94A5 20 1A                            JR      NZ, Test29Failed
 22++ 94A7 23                               INC     HL
 23++ 94A8 7E                               LD      A, (HL)
 24++ 94A9 FE 35                            CP      '5'
 25++ 94AB 20 14                            JR      NZ, Test29Failed
 26++ 94AD 23                               INC     HL
 27++ 94AE 7E                               LD      A, (HL)
 28++ 94AF FE 33                            CP      '3'
 29++ 94B1 20 0E                            JR      NZ, Test29Failed
 30++ 94B3 23                               INC     HL
 31++ 94B4 7E                               LD      A, (HL)
 32++ 94B5 FE 35                            CP      '5'
 33++ 94B7 20 08                            JR      NZ, Test29Failed
 34++ 94B9 23                               INC     HL
 35++ 94BA 7E                               LD      A, (HL)
 36++ 94BB FE 00                            CP      0               ; Null terminator
 37++ 94BD 21 C9 94                         LD      HL, MsgTestCase029
 38++ 94C0 C8                               RET     Z               ; Z set is test passed, else test failed.
 39++ 94C1 21 C9 94     Test29Failed:       LD      HL, MsgTestCase029
 40++ 94C4 3E 1D                            LD      A, 29
 41++ 94C6 C3 AB 8C                         JP      PrintFailedMessage
 42++ 94C9
 43++ 94C9 20 43 76 74  MsgTestCase029:     DB " Cvt. 65535", 0
 43++ 94CD 2E 20 36 35
 43++ 94D1 35 33 35 00
 44++ 94D5
# file closed: TestCase029.asm
 30+  94D5                              INCLUDE "TestCase030.asm"  ; Convert 12345 in both modes
# file opened: TestCase030.asm
  1++ 94D5              TestCase030:        ; Test30 - Convert 12345 in both modes, should produce "12345" in both modes
  2++ 94D5                                  ; First test without leading zeros
  3++ 94D5 21 39 30                         LD      HL, 12345       ; Value to convert
  4++ 94D8 3E 01                            LD      A, 1            ; No leading zeros
  5++ 94DA 11 11 8D                         LD      DE, ConversionBuffer
  6++ 94DD CD 58 8B                         CALL    ConvertToDecimal
  7++ 94E0              ;
  8++ 94E0              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
  9++ 94E0              ;
 10++ 94E0                                  ; Check length should be 5
 11++ 94E0 FE 05                            CP      5
 12++ 94E2 20 1B                            JR      NZ, Test30Failed
 13++ 94E4
 14++ 94E4                                  ; Check result should be "12345"
 15++ 94E4 CD 07 95                         CALL    CheckTest30Result
 16++ 94E7 20 16                            JR      NZ, Test30Failed
 17++ 94E9
 18++ 94E9                                  ; Now test with leading zeros (should be same result)
 19++ 94E9 21 39 30                         LD      HL, 12345       ; Value to convert
 20++ 94EC 3E 00                            LD      A, 0            ; With leading zeros
 21++ 94EE 11 11 8D                         LD      DE, ConversionBuffer
 22++ 94F1 CD 58 8B                         CALL    ConvertToDecimal
 23++ 94F4              ;
 24++ 94F4              ;                    CALL    PrintLengthAndString ; use to debug test when it fails
 25++ 94F4              ;
 26++ 94F4                                  ; Check length should still be 5
 27++ 94F4 FE 05                            CP      5
 28++ 94F6 20 07                            JR      NZ, Test30Failed
 29++ 94F8
 30++ 94F8                                  ; Check result should still be "12345"
 31++ 94F8 CD 07 95                         CALL    CheckTest30Result
 32++ 94FB 21 27 95                         LD      HL, MsgTestCase030
 33++ 94FE C8                               RET     Z               ; Z set is test passed, else test failed.
 34++ 94FF 21 27 95     Test30Failed:       LD      HL, MsgTestCase030
 35++ 9502 3E 1E                            LD      A, 30
 36++ 9504 C3 AB 8C                         JP      PrintFailedMessage
 37++ 9507
 38++ 9507              CheckTest30Result:  ; if NZ set on return, test failed.
 39++ 9507 21 11 8D                         LD      HL, ConversionBuffer
 40++ 950A 7E                               LD      A, (HL)
 41++ 950B FE 31                            CP      '1'
 42++ 950D C0                               RET     NZ
 43++ 950E 23                               INC     HL
 44++ 950F 7E                               LD      A, (HL)
 45++ 9510 FE 32                            CP      '2'
 46++ 9512 C0                               RET     NZ
 47++ 9513 23                               INC     HL
 48++ 9514 7E                               LD      A, (HL)
 49++ 9515 FE 33                            CP      '3'
 50++ 9517 C0                               RET     NZ
 51++ 9518 23                               INC     HL
 52++ 9519 7E                               LD      A, (HL)
 53++ 951A FE 34                            CP      '4'
 54++ 951C C0                               RET     NZ
 55++ 951D 23                               INC     HL
 56++ 951E 7E                               LD      A, (HL)
 57++ 951F FE 35                            CP      '5'
 58++ 9521 C0                               RET     NZ
 59++ 9522 23                               INC     HL
 60++ 9523 7E                               LD      A, (HL)
 61++ 9524 FE 00                            CP      0               ; Null terminator
 62++ 9526 C9                               RET
 63++ 9527
 64++ 9527 20 43 76 74  MsgTestCase030:     DB " Cvt. 12345", 0
 64++ 952B 2E 20 31 32
 64++ 952F 33 34 35 00
 65++ 9533
# file closed: TestCase030.asm
 31+  9533                              INCLUDE "TestCase031.asm"  ; Multiply 8x8 - PERFORMANCE_COMPACT- Unified Refactor
# file opened: TestCase031.asm
  1++ 9533              TestCase031:        ; Test case 31: 6 ร 3 = 15         - Added due to Unified Refactor
  2++ 9533 3E 06                            LD      A, 6                    ; Multiplicand
  3++ 9535 06 03                            LD      B, 3                    ; Multiplier
  4++ 9537 0E 00                            LD      C, PERFORMANCE_COMPACT
  5++ 9539 CD C2 86                         CALL    Multiply8x8_Unified
  6++ 953C
  7++ 953C                                  ; Result should be 18 in HL
  8++ 953C 11 12 00                         LD      DE, 18                  ; Expected result
  9++ 953F B7                               OR      A                       ; Clear carry
 10++ 9540 ED 52                            SBC     HL, DE                  ; Compare result with expected
 11++ 9542 21 4B 95                         LD      HL, MsgTestCase031
 12++ 9545 C8                               RET     Z                       ; Z set is test passed, else test failed.
 13++ 9546 3E 1F        Test031Failed:      LD      A, 31                   ; Test number
 14++ 9548 C3 AB 8C                         JP      PrintFailedMessage
 15++ 954B
 16++ 954B 20 28 36 20  MsgTestCase031:     DB      " (6 x 3 = 18)", 0
 16++ 954F 78 20 33 20
 16++ 9553 3D 20 31 38
 16++ 9557 29 00
# file closed: TestCase031.asm
 32+  9559                              INCLUDE "TestCase032.asm"  ; Multiply 16x8 - PERFORMANCE_COMPACT - Unified Refactor
# file opened: TestCase032.asm
  1++ 9559              TestCase032:        ; Test case 32: 1000 ร 45 = 45000 (16x8 multiplication)
  2++ 9559 21 E8 03                         LD      HL, 1000        ; 16-bit multiplicand
  3++ 955C 06 2D                            LD      B, 45           ; 8-bit multiplier
  4++ 955E 0E 00                            LD      C, PERFORMANCE_COMPACT ; Set performance level
  5++ 9560 CD 2E 87                         CALL    Multiply16x8_Unified
  6++ 9563
  7++ 9563                                  ; Since 45000 fits in 16 bits, DE should be 0 and HL should be 45000
  8++ 9563 7A                               LD      A, D
  9++ 9564 B3                               OR      E               ; Check if high word is zero
 10++ 9565 20 0C                            JR      NZ, Test32Failed ; Should be zero for this test case
 11++ 9567
 12++ 9567                                  ; Check if HL = 45000
 13++ 9567 D5                               PUSH    DE              ; Save high result
 14++ 9568 11 C8 AF                         LD      DE, 45000       ; Expected low result
 15++ 956B B7                               OR      A               ; Clear carry
 16++ 956C ED 52                            SBC     HL, DE          ; Compare
 17++ 956E D1                               POP     DE              ; Restore high result
 18++ 956F 21 7B 95                         LD      HL, MsgTestCase032
 19++ 9572 C8                               RET     Z               ; Z set is test passed, else test failed.
 20++ 9573 21 7B 95     Test32Failed:       LD      HL, MsgTestCase032
 21++ 9576 3E 20                            LD      A, 32
 22++ 9578 C3 AB 8C                         JP      PrintFailedMessage
 23++ 957B
 24++ 957B 20 28 31 30  MsgTestCase032:     DB      " (1000 x 45 = 45000)", 0
 24++ 957F 30 30 20 78
 24++ 9583 20 34 35 20
 24++ 9587 3D 20 34 35
 24++ 958B 30 30 30 29
 24++ 958F 00
# file closed: TestCase032.asm
 33+  9590                              INCLUDE "TestCase033.asm"  ; Multiply 16x8 - PERFORMANCE_COMPACT - Large Result Test
# file opened: TestCase033.asm
  1++ 9590              TestCase033:        ; Test case 33: 1000 ร 100 = 100000 (16x8 COMPACT multiplication)
  2++ 9590 21 E8 03                         LD      HL, 1000        ; 16-bit multiplicand
  3++ 9593 06 64                            LD      B, 100          ; 8-bit multiplier
  4++ 9595 0E 00                            LD      C, PERFORMANCE_COMPACT ; Set performance level
  5++ 9597 CD 2E 87                         CALL    Multiply16x8_Unified
  6++ 959A
  7++ 959A                                  ; Result should be 100000 = 0x0186A0 in DE:HL
  8++ 959A                                  ; DE should be 1 (0x01) and HL should be 34464 (0x86A0)
  9++ 959A 7A                               LD      A, D
 10++ 959B FE 01                            CP      1               ; Check if high word high byte is 1
 11++ 959D 20 10                            JR      NZ, Test33Failed
 12++ 959F 7B                               LD      A, E
 13++ 95A0 B7                               OR      A               ; Check if high word low byte is 0
 14++ 95A1 20 0C                            JR      NZ, Test33Failed
 15++ 95A3
 16++ 95A3                                  ; Check if HL = 34464 (0x86A0)
 17++ 95A3 D5                               PUSH    DE              ; Save high result
 18++ 95A4 11 A0 86                         LD      DE, 34464       ; Expected low result (0x86A0)
 19++ 95A7 B7                               OR      A               ; Clear carry
 20++ 95A8 ED 52                            SBC     HL, DE          ; Compare
 21++ 95AA D1                               POP     DE              ; Restore high result
 22++ 95AB 21 B7 95                         LD      HL, MsgTestCase033
 23++ 95AE C8                               RET     Z               ; Z set is test passed, else test failed.
 24++ 95AF 21 B7 95     Test33Failed:       LD      HL, MsgTestCase033
 25++ 95B2 3E 21                            LD      A, 33
 26++ 95B4 C3 AB 8C                         JP      PrintFailedMessage
 27++ 95B7
 28++ 95B7 20 28 31 30  MsgTestCase033:     DB      " (1000 x 100 = 100000)", 0
 28++ 95BB 30 30 20 78
 28++ 95BF 20 31 30 30
 28++ 95C3 20 3D 20 31
 28++ 95C7 30 30 30 30
 28++ 95CB 30 29 00
 29++ 95CE
# file closed: TestCase033.asm
 34+  95CE                              INCLUDE "TestCase034.asm"  ; Multiply 16x8 - PERFORMANCE_BALANCED - Large Result Test
# file opened: TestCase034.asm
  1++ 95CE              TestCase034:        ; Test case 34: 2000 ร 50 = 100000 (16x8 BALANCED multiplication)
  2++ 95CE 21 D0 07                         LD      HL, 2000        ; 16-bit multiplicand
  3++ 95D1 06 32                            LD      B, 50           ; 8-bit multiplier
  4++ 95D3 0E 01                            LD      C, PERFORMANCE_BALANCED ; Set performance level
  5++ 95D5 CD 2E 87                         CALL    Multiply16x8_Unified
  6++ 95D8
  7++ 95D8                                  ; Result should be 100000 = 0x0186A0 in DE:HL
  8++ 95D8                                  ; DE should be 1 (0x01) and HL should be 34464 (0x86A0)
  9++ 95D8 7A                               LD      A, D
 10++ 95D9 FE 01                            CP      1               ; Check if high word high byte is 1
 11++ 95DB 20 10                            JR      NZ, Test34Failed
 12++ 95DD 7B                               LD      A, E
 13++ 95DE B7                               OR      A               ; Check if high word low byte is 0
 14++ 95DF 20 0C                            JR      NZ, Test34Failed
 15++ 95E1
 16++ 95E1                                  ; Check if HL = 34464 (0x86A0)
 17++ 95E1 D5                               PUSH    DE              ; Save high result
 18++ 95E2 11 A0 86                         LD      DE, 34464       ; Expected low result (0x86A0)
 19++ 95E5 B7                               OR      A               ; Clear carry
 20++ 95E6 ED 52                            SBC     HL, DE          ; Compare
 21++ 95E8 D1                               POP     DE              ; Restore high result
 22++ 95E9 21 F5 95                         LD      HL, MsgTestCase034
 23++ 95EC C8                               RET     Z               ; Z set is test passed, else test failed.
 24++ 95ED 21 F5 95     Test34Failed:       LD      HL, MsgTestCase034
 25++ 95F0 3E 22                            LD      A, 34
 26++ 95F2 C3 AB 8C                         JP      PrintFailedMessage
 27++ 95F5
 28++ 95F5 20 28 32 30  MsgTestCase034:     DB      " (2000 x 50 = 100000)", 0
 28++ 95F9 30 30 20 78
 28++ 95FD 20 35 30 20
 28++ 9601 3D 20 31 30
 28++ 9605 30 30 30 30
 28++ 9609 29 00
 29++ 960B
# file closed: TestCase034.asm
 35+  960B                              INCLUDE "TestCase035.asm"  ; Multiply 16x8 - PERFORMANCE_MAXIMUM - Large Result Test
# file opened: TestCase035.asm
  1++ 960B              TestCase035:        ; Test case 35: 500 ร 200 = 100000 (16x8 MAXIMUM multiplication)
  2++ 960B 21 F4 01                         LD      HL, 500         ; 16-bit multiplicand
  3++ 960E 06 C8                            LD      B, 200          ; 8-bit multiplier
  4++ 9610 0E 02                            LD      C, PERFORMANCE_MAXIMUM ; Set performance level
  5++ 9612 CD 2E 87                         CALL    Multiply16x8_Unified
  6++ 9615
  7++ 9615                                  ; Result should be 100000 = 0x0186A0 in DE:HL
  8++ 9615                                  ; DE should be 1 (0x01) and HL should be 34464 (0x86A0)
  9++ 9615 7A                               LD      A, D
 10++ 9616 FE 01                            CP      1               ; Check if high word high byte is 1
 11++ 9618 20 10                            JR      NZ, Test35Failed
 12++ 961A 7B                               LD      A, E
 13++ 961B B7                               OR      A               ; Check if high word low byte is 0
 14++ 961C 20 0C                            JR      NZ, Test35Failed
 15++ 961E
 16++ 961E                                  ; Check if HL = 34464 (0x86A0)
 17++ 961E D5                               PUSH    DE              ; Save high result
 18++ 961F 11 A0 86                         LD      DE, 34464       ; Expected low result (0x86A0)
 19++ 9622 B7                               OR      A               ; Clear carry
 20++ 9623 ED 52                            SBC     HL, DE          ; Compare
 21++ 9625 D1                               POP     DE              ; Restore high result
 22++ 9626 21 32 96                         LD      HL, MsgTestCase035
 23++ 9629 C8                               RET     Z               ; Z set is test passed, else test failed.
 24++ 962A 21 32 96     Test35Failed:       LD      HL, MsgTestCase035
 25++ 962D 3E 23                            LD      A, 35
 26++ 962F C3 AB 8C                         JP      PrintFailedMessage
 27++ 9632
 28++ 9632 20 28 35 30  MsgTestCase035:     DB      " (500 x 200 = 100000)", 0
 28++ 9636 30 20 78 20
 28++ 963A 32 30 30 20
 28++ 963E 3D 20 31 30
 28++ 9642 30 30 30 30
 28++ 9646 29 00
 29++ 9648
# file closed: TestCase035.asm
 36+  9648                              INCLUDE "TestCase036.asm"  ; Divide 8x8 - PERFORMANCE_COMPACT- Unified Refactor
# file opened: TestCase036.asm
  1++ 9648              TestCase036:        ; Test case 36: 45 รท 7 = 6 remainder 3         - Added due to Unified Refactor
  2++ 9648 3E 2D                            LD      A, 45           ; Dividend
  3++ 964A 06 07                            LD      B, 7            ; Divisor
  4++ 964C 0E 00                            LD      C, PERFORMANCE_COMPACT
  5++ 964E CD A2 85                         CALL    Divide8x8_Unified
  6++ 9651
  7++ 9651                                  ; Result should be A=6, B=3
  8++ 9651 21 61 96                         LD      HL, MsgTestCase036
  9++ 9654 FE 06                            CP      6               ; Check quotient
 10++ 9656 20 04                            JR      NZ, Test36Failed
 11++ 9658 78                               LD      A, B            ; Get remainder
 12++ 9659 FE 03                            CP      3               ; Check remainder
 13++ 965B C8                               RET     Z               ; Z set is test passed, else test failed.
 14++ 965C 3E 24        Test36Failed:       LD      A, 36           ; test number
 15++ 965E C3 AB 8C                         JP      PrintFailedMessage
 16++ 9661
 17++ 9661 20 28 34 35  MsgTestCase036:     DB      " (45 / 7 = 6r3)", 0
 17++ 9665 20 2F 20 37
 17++ 9669 20 3D 20 36
 17++ 966D 72 33 29 00
# file closed: TestCase036.asm
 37+  9671                              INCLUDE "TestCase037.asm"  ; Divide 16x8 - PERFORMANCE_COMPACT - Unified Refactor
# file opened: TestCase037.asm
  1++ 9671              TestCase037:        ; Test case 37: 5000 รท 13 = 384 remainder 8 (16-bit division)
  2++ 9671 21 88 13                         LD      HL, 5000        ; Dividend (16-bit)
  3++ 9674 06 0D                            LD      B, 13           ; Divisor
  4++ 9676 0E 00                            LD      C, PERFORMANCE_COMPACT
  5++ 9678 CD 1A 86                         CALL    Divide16x8_Unified
  6++ 967B
  7++ 967B                                  ; Result should be HL=384, A=8
  8++ 967B F5                               PUSH    AF              ; Save remainder
  9++ 967C 11 80 01                         LD      DE, 384         ; Expected quotient
 10++ 967F B7                               OR      A               ; Clear carry
 11++ 9680 ED 52                            SBC     HL, DE          ; Compare quotient
 12++ 9682 21 92 96                         LD      HL, MsgTestCase037
 13++ 9685 20 05                            JR      NZ, Test37Failed
 14++ 9687 F1                               POP     AF              ; Restore remainder
 15++ 9688 FE 08                            CP      8               ; Check remainder
 16++ 968A C8                               RET     Z               ; Z set is test passed, else test failed.
 17++ 968B F5                               PUSH    AF              ; Balance the stack for drop thru
 18++ 968C F1           Test37Failed:       POP     AF              ; Clean up stack
 19++ 968D 3E 25                            LD      A, 37
 20++ 968F C3 AB 8C                         JP      PrintFailedMessage
 21++ 9692
 22++ 9692 20 28 35 30  MsgTestCase037:     DB      " (5000 / 13 = 384r8)", 0
 22++ 9696 30 30 20 2F
 22++ 969A 20 31 33 20
 22++ 969E 3D 20 33 38
 22++ 96A2 34 72 38 29
 22++ 96A6 00
# file closed: TestCase037.asm
 38+  96A7
# file closed: TestCases.asm
 42   96A7
 43   96A7              SaveNexFileOutput:
 44   96A7                              SAVENEX OPEN "Output/nextlibrary.nex", StartAddress
 45   96A7                              SAVENEX CORE 3, 0, 0                       ; Next core 3.0.0 required as minimum
 46   96A7                              SAVENEX CFG  0
 47   96A7                              SAVENEX AUTO
 48   96A7                              SAVENEX CLOSE
 49   96A7
# file closed: NextLibrary.asm
